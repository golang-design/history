# Go 语言历史

> 英文原版：[https://golang.design/history/](https://golang.design/history/)，来自 Changkun Ou 及其他贡献者

> 此翻译文档可能更新不及时，您可以查看英文原版获得最新更新。

此文档收集了Go语言开发过程中公开的讨论及提案，以全面地展现Go语言发展历史。

<a id="top"></a>

**Table of Contents**

* [Go 语言历史](#Go+%E8%AF%AD%E8%A8%80%E5%8E%86%E5%8F%B2)
  * [免责声明](#%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E)
  * [资料来源](#%E8%B5%84%E6%96%99%E6%9D%A5%E6%BA%90)
  * [起源](#%E8%B5%B7%E6%BA%90)
  * [贡献者](#%E8%B4%A1%E7%8C%AE%E8%80%85)
    * [核心作者](#%E6%A0%B8%E5%BF%83%E4%BD%9C%E8%80%85)
    * [编译运行时团队](#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9B%A2%E9%98%9F)
    * [小组会谈](#%E5%B0%8F%E7%BB%84%E4%BC%9A%E8%B0%88)
  * [时间线](#%E6%97%B6%E9%97%B4%E7%BA%BF)
  * [语言设计](#%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1)
    * [Misc](#Misc)
    * [切片 (1.2)](#%E5%88%87%E7%89%87+%281.2%29)
    * [包管理 (1.4, 1.5, 1.7)](#%E5%8C%85%E7%AE%A1%E7%90%86+%281.4%2C+1.5%2C+1.7%29)
    * [类型别名 (1.9)](#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D+%281.9%29)
    * [Defer (1.14)](#Defer+%281.14%29)
    * [错误值 (1.13)](#%E9%94%99%E8%AF%AF%E5%80%BC+%281.13%29)
    * [通道、选择器](#%E9%80%9A%E9%81%93%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8)
    * [泛型](#%E6%B3%9B%E5%9E%8B)
  * [编译工具链](#%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE)
    * [编译](#%E7%BC%96%E8%AF%91)
    * [连接器](#%E8%BF%9E%E6%8E%A5%E5%99%A8)
    * [调试器](#%E8%B0%83%E8%AF%95%E5%99%A8)
    * [竞争检测器](#%E7%AB%9E%E4%BA%89%E6%A3%80%E6%B5%8B%E5%99%A8)
    * [跟踪器](#%E8%B7%9F%E8%B8%AA%E5%99%A8)
    * [锁分析](#%E9%94%81%E5%88%86%E6%9E%90)
    * [构建](#%E6%9E%84%E5%BB%BA)
    * [模块](#%E6%A8%A1%E5%9D%97)
    * [gopls](#gopls)
    * [测试，x/perf](#%E6%B5%8B%E8%AF%95%EF%BC%8Cx%2Fperf)
  * [运行时核心](#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%B8%E5%BF%83)
    * [调度器](#%E8%B0%83%E5%BA%A6%E5%99%A8)
    * [执行栈](#%E6%89%A7%E8%A1%8C%E6%A0%88)
    * [内存分配器](#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8)
    * [垃圾收集器](#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8)
    * [统计](#%E7%BB%9F%E8%AE%A1)
    * [内存模型](#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)
    * [ABI](#ABI)
    * [Misc](#Misc)
  * [标准库](#%E6%A0%87%E5%87%86%E5%BA%93)
    * [syscall](#syscall)
    * [os, io, io/fs, embed](#os%2C+io%2C+io%2Ffs%2C+embed)
    * [go/*](#go%2F%2A)
    * [sync](#sync)
      * [Map](#Map)
      * [Pool](#Pool)
      * [Mutex, RWMutex](#Mutex%2C+RWMutex)
      * [Groups](#Groups)
      * [atomic](#atomic)
    * [time](#time)
    * [context](#context)
    * [encoding](#encoding)
    * [image, x/image](#image%2C+x%2Fimage)
    * [Mobile](#Mobile)
    * [misc](#misc)
  * [未分类但相关的链接](#%E6%9C%AA%E5%88%86%E7%B1%BB%E4%BD%86%E7%9B%B8%E5%85%B3%E7%9A%84%E9%93%BE%E6%8E%A5)
  * [有趣的事实](#%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%AE%9E)
  * [鸣谢](#%E9%B8%A3%E8%B0%A2)
  * [许可](#%E8%AE%B8%E5%8F%AF)

---

## 免责声明

- 很多内容是对于公开信息的主观理解
- 可能出现实际错误或拼写错误。如果某些内容和您的观点相违背，请参考原始链接
- 非常欢迎关于新内容、错误修复、拼写修复的合并请求
- 使用 Github Issue 进行讨论

[Back To Top](#top)

## 资料来源

有很多探索 Go 历史设计的平台，以下是这些平台的官方网站：

- [go.dev/blog](https://go.dev/blog)
- [dev.go.dev](https://dev.go.dev)
- [build.go.dev](https://build.go.dev/)
- [farmer.go.dev](https://farmer.go.dev/)
- [go.dev/talks](https://go.dev/talks)
- [go.dev/doc](https://go.dev/doc)
- [go.dev/pkg](https://go.dev/pkg)
- [github.com/golang/go](https://github.com/golang/go)
- [github.com/golang/proposal](https://github.com/golang/proposal)
- [github.com/golang/go/wiki](https://github.com/golang/go/wiki)
- [go-review.googlesource.com](https://go-review.googlesource.com)
- [groups.google.com/g/golang-nuts](https://groups.google.com/g/golang-nuts)
- [groups.google.com/g/golang-dev](https://groups.google.com/g/golang-dev)
- [groups.google.com/g/golang-tools](https://groups.google.com/g/golang-tools)

[Back To Top](#top)

## 起源

Go 是由一个小组织以及语言社区的用户推动的。以下是一些核心贡献者，你可能会对他们杰出的工作感兴趣。

Go 的起源很吸引人。通过这些人举办的讲座，您可以了解到相关的口述历史和有趣的故事。

例如，您可以选择这些有关 Go 历史壮举的讲座作为起点（仅建议）： `talk/rob2007`, `talk/rob2009`, `talk/rob2010b`, `talk/rob2010d`, `talk/rob2011a`, `talk/rob2013a`, `talk/rob2019`, `talk/robert2015`, `talk/russ2014`, `steve2019b`, etc.

[Back To Top](#top)

## 贡献者

### 核心作者

Go 最初由 Rob, Robert 和 Ken 创建。Rob 跟 Robert 谈论 C++ 缓慢的编译时间， 而 Ken 刚好在隔壁办公室。之后 Ian 因为兴趣加入了这个项目，编写了 [gccgo](https://github.com/golang/gofrontend)。Rob 和 Ken 退休后，Robert 和 Ian 目前为 Go 添加泛型。Russ 也是早期的核心贡献者，那时候他是谷歌的新人，Rob 在 [Plan 9](https://9p.io/plan9/) 项目就认识了 Russ，并邀请他加入 Go 团队。Russ 做了很多基础工作，包括早期的 Go 编译器、运行时以及 Go 1.5 启动时的巨大提升。Russ 现在是 Go 团队的 Tech Lead。

- Rob Pike. (Robert C. Pike 科学硕士) [Website](http://herpolhode.com/rob/), [Blog](https://commandcenter.blogspot.com/), [GitHub](https://github.com/robpike), [Twitter](https://twitter.com/rob_pike), [Reddit](https://www.reddit.com/user/robpike).（退休）
  + 毕业院校：多伦多大学（理学学士），加州理工
  + [talk/rob2007](https://www.youtube.com/watch?v=hB05UFqOtFA) <details><summary>编程语言的高级主题：并发/通过 Newsqueak 发送消息。2007年5月9日。</summary>
    <p><b>总结：</b> 在 2007 年 5 月的 Google Tech Talk 中，贝尔实验室的 UTF-8 和 Plan 9 的创建者 Rob Pike 讨论了他的编程语言 New Squeak，它具有有趣的并发和消息传递机制。派克认为，有两种方法可以解决我们生活的并发世界与我们用来编写程序的顺序计算机之间的不匹配：让世界看起来同步和顺序，或者让软件并发。 Pike 讨论了线程、共享内存和锁等低级概念在并发编程方面的局限性。 New Squeak 是一种编程语言，创建于 1988 年，用于解决在为并发世界编写软件时出现的问题。它具有作为函数的 lambda、流程管理软件和作为一等公民的通道。该语言启发了其他语言，并在贝尔实验室用作系统语言几年来构建有趣的工具。演讲的重点是 New Squeak 中的流程和通道，以及如何使用这些概念编写程序。通道是编程中使用的一种通信工具，可减少通信所需的令牌数量。 CSP 中的通道由 New Squeak 中的关键字 Chan 引入，是无缓冲的同步通信端口，用于在进程之间同步和传递值。 New Squeak 的通道和选择语句支持潜在的通信并允许进程阻塞，直到一个或多个通信可以继续进行。本文介绍了一种具有 n 路多路复用的简单语言，并提供了一个将连续整数打印到通道的程序。它还解释了素数筛选和过滤过程的概念，以查找计算得出的所有素数。该系统还可用于操纵幂级数。 本文以 Newspeak 语言为例，讨论了接口和通道在编程中的使用。作者在 Plan 9 中讨论了用于构建窗口系统的系统模型，其中涉及将组件定义为通过通道捕获通信和数据流的接口。这种方法在 Plan 9 中的所有主要用户级服务中都使用过，并且由于作者以前在编程中使用并发模型的经验而变得更加容易。该模型允许组件之间进行复杂的交互，并允许自己组合接口，而不仅仅是状态机。作者还讨论了调试并发程序的挑战以及类 CSP 库在实现选择操作方面的局限性。他们提出了 shim 接口的想法，可以保证无死锁操作，并可以隔离和杀死行为不端的客户端。 Squint 解释器是 1988 年的代码，缺少许多用于图形和其他功能的库。讨论了在 C++ 互斥体之上实现通信通道模型的想法，并讨论了通道与回调的成本。可以进行优化，为不同形式的选择生成更紧凑的代码。</p></details>
  + [talk/rob2009](https://changelog.com/podcast/3) Go 编程语言。2009年11月27日。
  + [talk/rob2010a](https://www.youtube.com/watch?v=jgVhBThJdXc) <details><summary>Go 编程。谷歌2010年网络开发者年会。2010年5月20日。</summary>
    <p><b>总结：</b> 在 Google I/O 2010 视频节目“Go 编程”中，Rob Pike 和 Russ Cox 讨论了 Go 编程语言的独特功能和原理。他们强调使用 Go 特有的核心概念和习惯用法的重要性，而不是翻译其他语言的代码。 Go 的一个关键特性是它的不同类型，包括基本类型和复合类型。 Pike 和 Cox 解释说，Go 是面向对象的，但不是面向类型的，这意味着它没有类或继承。它们还强调了 Go 的隐式性质，其中可以省略类型声明。并发性是 Go 编程的另一个重要方面。 Pike 和 Cox 解释说 Go 专注于并发编程而不是并行编程。他们讨论了并发的好处，以及它如何允许构建能够有效利用多核的结构良好的程序。该视频节目还深入探讨了 Go 编程中接口的使用。接口用于定义不同类型可以实现的通用方法，从而实现代码重用和灵活性。 Pike 和 Cox 提供了如何在 Go 的分组密码包中使用接口的示例。演讲者将 Go 与其他语言（例如 Java）进行了比较，并强调了使用 Go 实现接口的优势。他们提到了多个包装器的灵活性和满足多个接口的需求。本集中还讨论了将读者链接在一起以解密和解压缩数据的概念。 Pike 和 Cox 解释了分布式系统中负载平衡的概念，并描述了一个将任务分配给工作人员的简单模型。他们讨论了负载均衡器在处理请求以及请求和响应通道的使用中的作用。 在整个剧集中，Pike 和 Cox 强调了 Go 的独特原理和功能，例如闭包和通道，这使其成为并发编程的首选。他们还提到了 Go 对于不同环境的适用性，例如服务器、桌面和移动设备。总之，Google I/O 2010 视频的“Go 编程”一集深入概述了 Go 编程语言。 Pike 和 Cox 强调了其独特的功能，例如不同的类型、并发性和接口的使用。他们将 Go 与其他语言进行比较，并讨论其并发编程的优势。总的来说，这一集展示了 Go 的强大功能和效率及其在各种编程环境中的潜力。</p></details>
  + [talk/rob2010b](https://www.youtube.com/watch?v=-_DKfAn4pFA) <details><summary>Go 并发风格的起源。新兴语言集会2010。2010年7月21日。</summary>
    <p><b>总结：</b> 在题为“Rob Pike. Go 并发风格的起源”的视频节目中，Rob Pike 讨论了 Go 编程语言中并发的起源和概念。他强调了 Tony Hoare 在 1978 年发表的关于通信顺序过程 (CSP) 的论文的影响，该论文强调了顺序过程的通信和并行组合。 Pike 将 CSP 描述为一种数学且优雅的语言，专注于发送者和接收者之间的通信和同步。 Pike 解释了如何并行组合进程（类似于管道），并提到 CSP 的局限性，例如无法动态创建进程或使用 send 作为防护，以及缺乏对线程或互斥体的支持。他还讨论了并发编程模型的发展和奥卡姆语言的出现，这为无需锁的多处理器和并发算法编程奠定了基础。该视频节目还涉及 Limbo 语言向 Go 的发展，强调了 Go 的 CSP 模型的强大功能及其对通信和并发通道的使用。通道被描述为能够在进程之间传输数据和功能的一流值。 Pike 提到 lf 语言的开发，由于缺乏垃圾收集而面临挑战，但 Limbo 解决了这些问题，并在其有限的领域取得了更大的成功。讨论了在编程中使用并发的好处，特别是在 CSP 模型的上下文中。 Pike 强调并发性如何在密码学和图形等领域实现高效计算，同时还提供代码可重用性的机会。 他建议阅读原始 CSP 论文以更深入地了解该语言，并讨论过程控制和通信的概念，强调了解协同例程的强大功能的重要性。 Pike还强调了用Go编写并发程序的简便性和安全性，强调Go的并发特性是自然且易于使用的。他提到了 Go 内存系统的安全性和类型安全性，警告不要使用 unsafe 包。该语言已成功应用于各种应用程序，包括高流量网站，并提供强大的通信通道能力。视频剧集最后以系统语言解释了通道的概念，其中类型决定了可以通过通道发送的内容。与传统的共享和锁定模型相比，它讨论了这种方法的效率和灵活性。 Pike 还提到了编程中传递指针的概念以及它与效率和所有权的关系，强调了理解指针一旦传递，就不再是原始所有者关心的重要性。这一集强调了让事情变得简单可以提高效率的想法，这被视为一个积极的观点。</p></details>
  + [talk/rob2010c](https://www.youtube.com/watch?v=5kj5ApnhPAE) <details><summary>`public static void`，2010年 OSCON 大会。2010年7月22日。</summary>
    <p><b>总结：</b> 在 OSCON 2010 的题为“Public Static Void”的视频节目中，Google, Inc. 的软件工程师 Rob Pike 讨论了与编程语言及其复杂性相关的各种主题。 Pike 强调早期编程语言的价值，强调与现代软件开发的复杂性和噪音相比，它们的简单性和效率。 Pike 面临的挑战之一是在 C++ 中调用函数的复杂性以及缺乏垃圾收集。他还提到非专业程序员在选择不同的 Boost 模板化指针类型进行内存管理时遇到的困难。 Pike 承认 C++ 等复杂编程语言的复杂性以及由此产生的问题。还讨论了 C++ 和 Java 在编程中的重要性，特别是在教育和工业中。 Pike 质疑为什么这些语言已成为标准，并提供了它们发展的简化历史。他不同意使用 C++ 和 Java 进行教学的趋势，认为这两种语言都过于复杂和冗长，不便于用户使用。强调了在软件开发中使用模式的局限性，作者认为随着编程语言的改进，对模式的需求可能会减少。面向对象的编程语言因官僚主义和重复性而受到批评，该文本鼓励人们认识替代编程模型。解决了重复和无意义代码的问题，并给出了一个例子来说明在编程中避免此类代码的重要性。还讨论了在代码中使用不明确的整数和布尔值的问题，强调了清晰的数据声明的必要性。 探讨了编程语言的官僚本质，Python、Ruby 和 JavaScript 等流行语言因变得繁琐而受到批评。 Haskell 和 Scala 等新编程语言的出现被视为对使用旧语言的挫败感的回应。动态解释语言优于编译静态语言的误解受到了挑战。讨论了新旧编程语言的局限性，并争论了需要一种结合了两者优点的语言。总之，视频节目深入探讨了编程语言的复杂性和挑战。它强调了编程语言的简单性、效率和用户友好性的重要性，并建议需要更好的解决方案来减轻开发人员的负担。 Go 编程语言被认为是满足这些要求的一种尝试，它将静态类型编译语言的安全性和性能与动态类型解释语言的表达能力和便利性结合起来。</p></details>
  + [talk/rob2010d](https://www.youtube.com/watch?v=7VcArS4Wpqk) <details><summary>另一种 Go 语言设计。2010年8月27日。</summary>
    <p><b>总结：</b> 在题为“Another Go at Language Design”的视频节目中，Google, Inc. 的首席工程师 Rob Pike 讨论了 Go 编程语言的开发。 Pike 解释说，Go 的创建是因为需要一种能够解决大型代码库所面临的挑战的语言。他强调，Go 的开发是许多才华横溢的人共同努力的成果，并对与他一起工作的才华横溢的人表示感谢。派克讨论了计算机科学中“唯一正确的方法”的概念以及它如何依赖于工具、问题和信念。他提到即将举行的关于动态语言和静态技术的演讲。 Pike 还分享了关于早期编程语言的简单性和有效性的一句话。该视频节目强调了管理 C 和 C++ 程序中的依赖关系的挑战，这可能导致编译时间变慢并阻碍可扩展性。它引入了 Go 作为替代方案，强调了它有效处理包和依赖项的能力。讨论了 Go 的优点，包括它的速度以及更快地编译和运行程序的能力。作者建议将编译器包含在运行时系统中，以使该过程更加高效。强调了新的、干净的编译器的价值，因为它可以显着减少构建时间并提高整体性能。本集还解释了 Go 中的方法和接口，涵盖方法声明的语法和示例。讨论了使用接口来定义行为，以及任何类型都可以满足的空接口的概念。探讨了空接口在控制打印行为方面的强大功能，并提到了 printf 函数的实现。 引入隐式接口，强调类型安全和约定的重要性。使用“阅读器”接口的示例讨论了接口提供的灵活性和抽象性。解释了在工作池中使用互斥体和通道来管理数据共享和通信。讨论了并发服务器软件中垃圾收集的重要性，以及 Go 如何提供本质安全性并简化接口设计。提到了在低级编程中使用“不安全”库及其潜在风险。强调了现代机器中边界检查循环性能的提高以及 Go 中缓冲区溢出漏洞利用风险的降低。讨论了使用 Go 进行系统开发的优点，包括其无符号类型、位级操作和内存布局控制等功能。强调了Go的设计原则，包括其控制性、安全性、简单性和清晰度。本集解释了 Go 如何提供对内存分配和使用的控制，同时确保安全而不牺牲性能。还提到了Go中的可见性规则和常量的概念。总体而言，该视频节目赞扬了 Go 编程语言的简单性、效率和生产力优势。它强调了它在大规模软件开发中的使用，包括在谷歌内部，以及它有利的许可和开源开发。本集还讨论了编程中的各种概念，包括包命名空间、异常、类和继承以及并发模型中的通道。它强调了Go的协同设计过程中团队合作和一致决策的重要性。</p></details>
  + [talk/rob2011a](https://www.infoq.com/interviews/pike-concurrency/) 编程语言中的并行性和并发性。2011年2月17日。
  + [talk/rob2011b](https://www.infoq.com/interviews/pike-google-go/) Go 语言：并发、类型系统、内存管理和垃圾回收。2011年2月25日。
  + [talk/rob2011c](https://www.youtube.com/watch?v=HxaD_trXwRE) <details><summary>Go 词法分析。2011年8月30日。</summary>
    <p><b>总结：</b> 在 Google 技术用户组的这一集中，Rob Pike 发表了有关 Go 中的词法扫描的演讲。该演讲于 2011 年 8 月 30 日星期二发表，重点讨论了 Go 编程语言及其与解决计算中结构不匹配问题的相关性。 Pike 首先解释了编程语言中词位和标记的概念。他讨论了标记化的挑战以及使用词法分析工具的优点和缺点。 Pike 认为编写自定义词法分析器通常更有效，并强调了跨编程语言适应性的重要性。然后讨论编写词法分析器的过程，其中涉及定义状态和操作。 Pike 提出了一种更好的当前状态机模型方法，即不断移动到下一个状态而不是丢弃当前状态。他引入了状态函数的概念，状态函数是返回另一个状态函数的函数，可以在词法分析器中用于循环不同的状态。 Pike 还解释了 Go 通道如何实现词法分析器和解析器之间的通信。他解释了词法分析器中“开始”和“暂停”等变量的用途，并描述了 Lex Text 在扫描输入中的作用。还讨论了操作块的结构以及转换到新状态的过程。然后，演讲深入探讨了在模板系统中解析字符的过程，包括如何处理不同的字符以及辅助函数的使用。 Pike 解释了词法分析器中接受器的概念，这有助于扫描复杂的输入。他还讨论了如何对字符串中的数字进行词法分析，包括不同的数字格式以及使用工具查找数字结尾。 Pike 强调了错误检查在解析和验证数字输入中的重要性。他提到使用解析器库将输入转换为数字，从而使程序员免于手动转换。还解释了状态机中错误函数的概念，以及它们在创建格式化错误消息中的作用。演讲最后讨论了在 Go 编程初始化期间运行 Go 例程以完成的挑战。 Pike 建议通过更改输入并使用没有通道的传统词法分析 API 来解决方案。解释了将现有代码转换为使用传统词法分析 API 的过程，以及编程中的运行循环和选择语句的概念。总的来说，Pike 的演讲提供了有关 Go 中词法扫描的宝贵见解，并为程序员面临的常见挑战提供了实用的解决方案。</p></details>
  + [talk/rob2012a](https://www.youtube.com/watch?v=f6kdp27TYZs) <details><summary>Go 并发模式。谷歌2012年网络开发者年会。2012年7月2日。</summary>
    <p><b>总结：</b> 在题为“Google I/O 2012 - Go 并发模式”的视频节目中，Rob Pike 讨论了并发在设计高性能网络服务中的重要性。 Pike 是一位著名的编程专家，他重点介绍了 Go 的并发原语，例如 goroutine 和通道，它们提供了一种简单而有效的方式来表达并发执行。 Pike 首先解释了并发的概念及其实际用途。他澄清 Go 是一种并发语言，而不是并行语言，并讨论了即使在单个处理器上运行，并发代码仍然可以具有有用的结构。他还讨论了并发编程思想和语言的起源，从而导致了 Go 的发展。派克强调这些语言的独特特征和知识深度。该视频深入探讨了 Go 编程中 goroutine 的概念以及它们如何允许多个函数的并发执行。 Pike 强调了通信和同步在创建适当的并发程序中的重要性。他对 Go 中的通道进行了全面的解释，这对于并发编程至关重要。 Pike 涵盖了通道上值的声明、初始化、发送和接收。他强调通道操作是阻塞的，并充当 goroutine 之间的同步机制。 Pike 还提到了缓冲通道的使用以及使用通道进行通信和同步而不是共享内存的 Go 方法。本集探讨了 Go 编程中并发和 select 语句的使用。 select 语句被强调为 Go 并发模型的一个关键特性，允许更轻松地控制基于通信的程序行为。 Pike 讨论了非阻塞通信、超时以及使用退出通道来表示进程结束。他强调了适当通信的重要性，以避免程序过早关闭，以及程序之间需要复杂的通信以实现同步。 Pike 还讨论了 goroutine 的概念，它是编程中的轻量级元素。他用运行 100、000 个 gopher 的例子来说明 goroutine 的速度和效率。 Pike 解释了 Google 搜索的工作流程，包括使用独立执行的后端来查找和提供搜索结果。他描述了测试程序速度的过程，并测量获得搜索结果所需的时间。 Pike 解释了如何为每个后端启动 goroutine 使搜索过程并发和并行，从而减少等待时间。本集最后讨论了在 Go 编程中使用并发的优点。 Pike 强调了与其他方法相比，使用 Go 的简单性和可靠性。他还讨论了并发工具在软件构建中的使用以及在尝试并发程序时谨慎的重要性。 Pike 解决了有关 Go 中的通道锁定、垃圾收集、堆栈分配和选择控制结构的问题。总体而言，该视频节目全面探讨了 Go 的并发特性及其在设计高性能网络服务中的实际应用。</p></details>
  + [talk/rob2012b](https://www.youtube.com/watch?v=FTl0tl9BGdc) <details><summary>为什么学习Go？2012年9月12日。</summary>
    <p><b>总结：</b> 在这个题为“为什么学习 Go？”的视频节目中，Go 编程语言的联合创始人 Rob Pike 讨论了对一种能够有效满足现代计算需求的新编译语言的需求。 Pike 认为，虽然 C、C++ 和 Java 等语言已经足以用于服务器软件开发，但它们并不能直接解决现代计算环境的属性。随着网络、集群计算和大数据的兴起，人们越来越需要一种高效且可以在多台机器上运行的语言。 Pike 强调了 Go 编程中依赖管理的重要性以及它如何有助于缩短构建时间。与其他语言不同，Go 的导入机制和干净的依赖关系层次结构可以防止冗余导入和不必要的重新编译。这导致构建时间显着加快，与其他语言的几分钟或几小时相比，Go 程序在几秒钟内即可构建。最近发布的 Go 第 1 版提供了稳定性和锁定的 API，导致该语言的采用率有所增加。 Pike 强调，Go 社区优先考虑语言的有效使用，而不是不断发布新版本。这种对稳定性和可用性的关注促进了该语言的流行和广泛采用。 Pike 最后表示，他很高兴有机会强调利用高效、快速的语言来完成当前任务的重要性，而不是仅仅关注其开发。他认为Go是一种非常适合当今现代计算机环境的下一代语言，具有流动性、易于构建以及构建大型程序的效率。总之，Rob Pike 的视频节目“为什么学习围棋？” 讨论了对一种能够满足现代计算需求的新编译语言的需求。他强调了 Go 编程中依赖管理的重要性，这有助于加快构建时间。最近发布的 Go 版本 1，以其稳定性和锁定性 - API 的出现，导致该语言的采用率不断提高。Pike 强调了利用高效、快速的语言来完成当前任务的重要性，而不是仅仅关注其开发。总体而言，Go 被视为当今现代计算机的下一代语言环境。</p></details>
  + [talk/rob2013a](https://www.youtube.com/watch?v=bj9T2c2Xk_s) <details><summary>Go 1 的路径图。2013年3月14日。</summary>
    <p><b>总结：</b> 在题为“Go 1 之路”的视频节目中，Rob Pike 和 Andrew Gerrand 在 OSCON 2012 上讨论了 Go 1 的开发和发布。该节目首先讨论了 Go 编程语言的开发，该语言旨在解决Google 的软件编写问题。 Go 是一种静态类型和编译语言，专注于使用接口和本机并发支持来编写程序。然后演讲者深入探讨了 Go 项目的成长和发展，包括 Mercurial 版本控制系统和 Rietveld 代码审查插件的使用。他们强调了维护稳定性和实施每周快照以确保稳定性所面临的挑战。然而，这引起了贡献者和用户的困惑。为了解决版本倾斜问题，实施了正式的发布流程，但用户仍然难以保持最新状态。这导致了名为“go fix”的强大工具的开发，该工具可以解析和重写 Go 代码，使用户更轻松地将代码更新到该语言的最新版本。虽然该工具对 Go 项目有利，但也有缺点，例如代码改动增加以及 Go 被认为是不稳定的语言，从而阻碍了一些公司的采用。然后讨论了 Go 第一个版本的开发过程，目的是解决人们对其不稳定性的担忧，并为公司提供一个可靠的版本来依赖。该过程涉及解决问题、改进语言及其库以及构建新的构建工具集。开发人员参与开源社区（尤其是 Windows）至关重要。 Go 1 的发布标志着开发方法的转变，重点关注长期兼容性和对 Windows 支持的改进。语言变化包括引入新的符文类型和 API 的改进。引入新的“go”工具消除了对 make 文件和其他构建脚本的需求，从而改进了依赖项管理和开发工作流程。 Go 1 还带来了文档和测试方面的改进，重新设计的网站提供了简化的安装说明和全面的文档。该版本对 Go 编程社区产生了积极影响，因为开发人员将他们的努力转向提高性能、稳定性和错误修复。 Go 1 背后的开发团队已将重点转移到使用 Go 本身并收集未来版本的反馈。积极的开发正在进行中，重点是稳定性、错误修复和效率提高。对编译器的代码生成和垃圾收集器进行了重大改进。该团队还致力于可移植性和开发新的库。总之，视频节目深入介绍了 Go 1 的开发和发布，强调了所面临的挑战、所做的改进以及它对 Go 编程社区的积极影响。演讲者强调干净、严格的依赖管理的重要性，以及通过多样化的演讲和引人入胜的教程接触更广泛受众的必要性。</p></details>
  + [talk/rob2013b](https://www.infoq.com/presentations/Go-Google/) Go 在谷歌。2013年4月13日。
  + [talk/rob2013c](https://changelog.com/podcast/100) Go 开发（Rob Pike 和 Andrew Gerrand)。2013年8月14日。
  + [talk/rob2013d](https://www.youtube.com/watch?v=cN_DpYBzKso) <details><summary>并发不是并行。2013年10月20日。</summary>
    <p><b>总结：</b> 在题为“并发不是并行性”的视频节目中，Rob Pike 在 Heroku Waza 2012 上发表演讲。他探讨了编程语言中并发性和并行性之间的区别，重点是 Go 编程语言。 Pike 认为并发优于并行，并澄清了围绕这些概念的误解。 Pike 强调了通信在协调并发任务中的重要性，并引用了 Tony Hoare 的关于将顺序进程通信作为高度重视的资源的论文。他还讨论了 Go 中的 select 语句，它充当多路并发控制开关。本集深入探讨了使用 Go 摆脱过时手册的实际问题以及对高效执行工具的需求。 Pike 介绍了使用多个 go 更有效地移动书籍的想法，强调了并发和并行的概念。通过协调多个 go 的行动，可以加快该过程。本集探讨了实现更高吞吐量的不同设计模式和策略，例如引入分段转储和增加涉及的 go 数量。然而，它承认所使用的示例过于简单并且缺乏现实世界的相关性。 Pike 还讨论了书堆设计和 Web 服务架构之间的相似之处。他在Go编程语言中引入了goroutine的概念，它类似于线程，但更高效且更容易创建。 Go 例程允许并行执行并提高编程效率。本集解释了 Go 中如何使用通道在 Go 例程之间进行通信，并介绍了 select 的概念，它允许程序同时监听多个通道。 Pike 强调了 Go 例程相对于传统线程在效率和成本效益方面的优势。此外，本集讨论了并发 Go 编程中闭包和通道的使用。它解释了如何使用闭包来包装后台操作并同时执行任务，突出了它们的简单性和效率。本集还演示了如何使用通道来构建负载均衡器，展示了表达并发操作的简便性以及在 Go 中使用通道的好处。总的来说，本集探讨了并发的优势及其在构建高效算法中的作用。它讨论了繁忙系统中的负载平衡以及 Go 编程语言中通道的使用进行通信。本集区分了并发和并行性，并为进一步理解提供了额外的资源。派克对博子的邀请表示感谢。总之，Rob Pike 的视频节目“并发不是并行性”提供了有关编程语言中并发性和并行性之间差异的宝贵见解，重点关注 Go 编程语言。 Pike 强调了通信的重要性，介绍了 Go 中的各种概念和工具，并讨论了并发在构建高效算法方面的优势。</p></details>
  + [talk/rob2014a](https://www.youtube.com/watch?v=VoS7DsT1rdM) <details><summary>Hello Gophers! Gophercon 开幕演讲。2014年 Gophercon。2014年4月24日。</summary>
    <p><b>总结：</b> Rob Pike 在 GopherCon 2014 开幕主题演讲中探讨了 Go 编程语言的历史和发展。 Pike 讨论了 Go 规范的初步讨论和起草，以及创建第一个 Go 编译器时面临的挑战。他强调了程序的语法和功能随时间的变化，包括引入“print”关键字和修改“main”函数。强调了包在 Go 编程语言设计中的重要性。 Pike 解释了将代码包装到库中、控制依赖关系以及确保快速构建时间的重要性。他还讨论了包导入的概念、使用线性编译的好处以及“export”关键字的使用。还探讨了 Go 编程中初始化的重要性。 Pike 提到了在 C 中实现受控初始化所面临的挑战以及在 Go 中正确程序初始化的重要性。讨论了 Go 编程语言的各个方面，包括语法、导入和命名空间、格式化打印、UTF-8 处理以及分号的历史。 Pike 解释了反射驱动的格式化打印方法、Go 中 UTF-8 的重要性以及对非 ASCII 字符的独特处理。重点介绍了 Go 编程语言的发展和演变，强调了协作和小团队在其设计过程中的重要性。 Pike 提到了第一个用 Go 编写的并发程序，称为素数筛 (prime sieve) 及其结构。他还讨论了 CSP 编程语言的演变以及 Go 语法随时间的变化。 Go 编程语言的稳定性受到强调，因为它在近五年来基本保持不变。 Pike 提到，这种稳定性已经赢得了用户的信任，并以其快速编译器和二进制执行吸引了初学者。他还讨论了开发过程和开源社区的贡献。 Go 中的“选择”功能被强调对于实现并发和创建复杂结构至关重要。 Pike 讨论了实现 Go 语言调试器以及使用 Go 作为嵌入式语言的挑战。他提到了开源社区为应对这些挑战所做的持续努力。总体而言，Rob Pike 的 GopherCon 2014 开幕主题演讲全面概述了 Go 编程语言的历史、发展和独特功能。</p></details>
  + [talk/rob2014b](https://www.youtube.com/watch?v=PXoG0WX0r_E) <details><summary>大数计算器实现。悉尼 Go 集会。2014年11月19日。</summary>
    <p><b>总结：</b> 在名为“与 Rob Pike 一起实现 bignum 计算器”的 Golang-syd 视频节目中，著名程序员 Rob Pike 讨论了他开发类似 APL 的计算器语言的经验。本集涵盖了与计算器实施相关的各种主题以及在此过程中面临的挑战。派克首先回顾了名为 Hawk 的计算器的历史，该计算器最初是为了教育目的而开发的。他承认计算器的局限性，例如缺乏精度和浮点问题。 Pike 还提到他参与出版了一本有关 Unix 编程环境的书。然后讨论转向 30 年前的计算器的问题，包括计算不准确和不支持十六进制数字。 Pike 表达了他对能够处理更大数字的计算器的渴望，并解释了他在 Go 中实现 APL 解释器的决定。 APL 是 Ken Iverson 在 20 世纪 50 年代和 60 年代开发的编程语言，是一种具有基于线性代数的简单内核的突破性语言。 Pike 强调了 APL 的独特性，它使用特殊字符而不是关键字，使其成为一种有趣的学习和使用语言。他提到了看到 APL 实际运行的罕见情况，并提到了一段展示 APL 表达发展的视频。这一集还简要介绍了 IV，这是一种以肯·艾弗森 (Ken Iverson) 命名的编程语言，它仍处于早期阶段，但具有有趣的功能，例如有理数的精确算术和对大数的支持。 Pike 提到了 IV 在某些密码计算方面的潜力。然后，视频深入探讨了编程中的各种数学概念和运算。 它涵盖向量、矩阵、随机数和排序，强调使用 APL 进行计算及其创建复杂程序的潜力。还讨论了 APL 实现的局限性，特别是在基数 16 中。 Pike 进一步解释了扫描标记、将它们解析为解析树并在 Go 中实现数值处理器的上下文中评估结果的过程。他分享了设计基于并发的词法扫描器的经验，并讨论了开发过程中遇到和修复的错误。本集最后，派克讨论了算术语法和编程语言中的表达式解析。他解释了操作数、二元运算符和语句列表的规则，强调了 APL 中解析的简单性以及递归下降解析器的影响。总的来说，这一集深入了解了类似 APL 的计算器语言的实现以及在此过程中面临的挑战。 Pike 在分享他对不同编程语言的知识和热情时，在编程方面的专业知识和经验脱颖而出。</p></details>
  + [talk/rob2015a](https://www.youtube.com/watch?v=cF1zJYkBW4A) <details><summary>从 C 到 Go 的工具链变化。2015年 GopherFest。2015年6月10日。</summary>
    <p><b>总结：</b> 在 GopherFest 2015 的这一集中，Rob Pike 讨论了在 Go 编程语言中从使用 C 代码到使用 Go 代码的过渡。将编译器从 C 迁移到 Go 的决定是出于实际原因，例如更容易编写和调试、更好的模块化和工具以及对并行执行的支持。过渡的好处已经显现，包括简化两种共存语言的管理、改进测试和分析以及代码库的整体维护。讨论了用 C 语言实现并发垃圾收集器的挑战，包括类型歧义和别名问题。 GCC Go 中使用分段堆栈和不精确的堆栈数据收集被认为是应对这些挑战的解决方案。开发过程涉及将 C 代码从分段堆栈转换为连续堆栈，并将运行时转换为类型安全语言。将 Go 编译器从 C 转换为 Go 的决定是为了正确性并避免引入新的错误。使用自定义翻译器创建机器生成的 Go 编译器，将代码从 C 转换为 Go。生成的代码不是最佳的，但可以使用各种工具进行改进。提到了使用 Yak 编写的解析器以及手动配置的必要性。文本还解释了 Go 中的源到源转换器的工作原理，以及如何使用它来修复先前编译器生成的缓慢代码。讨论了 Go 编程语言中编译器和垃圾收集器之间的差异。 Go 编译器不会释放内存，从而导致开销。 Go编译器团队为了提高性能和内存使用率做了一些优化，比如使用math big包、减少内存使用、改进逃逸分析、手工调优等。 最近的变化使编译器速度提高了 15%，包括更好的逃逸分析和架构的统一。 Go Build 工具简化了将 Go 程序编译到不同架构和操作系统中的过程。它使代码更加可移植，减少了对 C 语言重复代码的需求。引入了新的可移植汇编器，可以更轻松地开发代码并实现跨架构的兼容性。该工具还包括一个带有翻译工具和库的链接器。讨论了 Go 编程语言的改进和未来计划，重点是增强性能。 Go 1.5 的发布包括新的汇编器、垃圾收集器和调度器等更新，从而使代码更干净、更快。工具链和运行时也得到了改进，使代码更易于测试和维护。尽管不同指令集的挑战仍然存在，但目标是使语言更加可移植和灵活。</p></details>
  + [talk/rob2015b](https://www.youtube.com/watch?v=PAAkCSZUG1c) <details><summary>Go 箴言。GopherFest。2015年11月18日。</summary>
    <p><b>总结：</b> 在 Gopherfest 2015 的这一集中，Rob Pike 讨论了与围棋游戏和 Go 语言编程相关的各种主题。他首先介绍了《围棋谚语图解》一书，该书提供了有关围棋游戏原理以及如何将其应用于编程的宝贵见解。派克强调了西方人在学习和精通围棋游戏时面临的困难，强调了所需的独特玩法和战略思维。接下来是编程，Pike 强调了代码格式化的重要性以及遵守 Go 格式化指南（特别是 gofmt）的好处。他强调了代码一致性和可读性的重要性，并讨论了使用小型接口和有效构建 API 的优势。 Pike 还提到了 Go 生态系统中接口的文化方面，以及使包中所有类型的零值变得有用的必要性。然后，Pike 深入研究了编程中的依赖树主题，并主张保持较小的依赖树。他建议复制一小部分代码而不是导入整个库可以加快编译速度、更轻松地维护和简单化。他还强调在代码中使用构建标签，使其更加紧凑并减少对其他部分的依赖，特别是在保护系统调用和思科使用以实现可移植性和兼容性方面。讨论了在 Go 中使用不安全包的缺点，Pike 不鼓励使用它，因为可能会导致崩溃和不稳定。他强调编写清晰简单的代码、避免巧妙的编码技术以及限制 Go 中反射的使用的重要性。 Pike 还强调了设计架构和命名组件对于用 Go 构建大系统的重要性。他强调需要一个好的名字来帮助理解设计并使编程感觉自然。此外，Pike 还讨论了以用户为中心的文档的重要性，该文档解释了函数的目的和用法。他建议在代码文档中使用谚语来有效地传达信息并解决争论。总之，Gopherfest 2015 的这一集提供了有关 Go 游戏和 Go 语言编程的宝贵见解。 Rob Pike 强调理解编程中关键概念的重要性，例如代码格式、小接口和有效的 API 结构。他还讨论了保持依赖树较小、避免使用不安全包以及在构建大型系统时设计架构和命名组件的重要性。总的来说，本集为 Go 生态系统中的程序员提供了宝贵的建议和原则。</p></details>
  + [talk/rob2015c](https://www.youtube.com/watch?v=rFejpH_tAHM) <details><summary>简单是复杂的。2015年 dotGo。2015年12月2日。</summary>
    <p><b>总结：</b> 在题为“dotGo 2015 - Rob Pike - 简单即复杂”的视频节目中，Rob Pike 讨论了编程语言 Go 的成功和复杂性。该领域的著名专家 Pike 解释说，虽然 Go 通常被描述为一种简单的语言，但它并不像看起来那么简单。 Pike 首先强调了 Go 成功中简单性的重要性。与其他融合各种来源功能的语言不同，Go 因其简单性而脱颖而出。然而，派克对语言通过采用其他语言的特性而趋向单一语言的趋势表示担忧，因为它限制了解决问题方法的多样性。他强调针对不同领域和思维方式优化不同语言的重要性。该视频还深入探讨了平衡代码简洁性和可读性的挑战。 Pike 强调，可读的代码更容易理解、处理、扩展和修复。他使用 APL 方言中称为“对话”的示例来说明简洁的程序如何难以阅读。 Pike 还讨论了使用更具表现力的编程功能和潜在的效率下降之间的权衡。他强调找到适当的平衡并选择适当的功能以确保编程的简洁性和表现力的重要性。详细探讨了 Go 简单性背后隐藏的复杂性。 Pike 讨论了 Go 的各个方面，例如数据类型、函数、接口和并发性。他强调良好实施和有效工具的重要性。 Pike 还强调了 Go 中垃圾收集的复杂性，尽管它缺乏用户界面。 他提到了 Go 并发模型的简单性，特别是 Go 例程，它允许轻量级子流程。然而，他解释说，Go 例程涉及幕后复杂的管理。该视频还涉及 Go 对 Unicode UTF-8、net/http 等神奇包以及并发性的支持。 Pike 强调 Go 的简单性和易用性以及它的受欢迎程度。他探讨了 Go 如何处理数字类型和常量，强调了设计该语言所涉及的复杂性。 Pike 讨论了使用常量和接口的挑战，以及包在作用域和编译中的重要性。尽管使用简单，Go 包却隐藏了很多复杂性。总之，视频节目全面概述了 Go 编程语言的特性和优势。 Pike 的见解揭示了 Go 简单性背后隐藏的复杂性，并强调了在编程中在简单性和表现力之间找到适当平衡的重要性。</p></details>
  + [talk/rob2016a](https://www.youtube.com/watch?v=KINIAgRpkDA) <details><summary>Go 汇编的设计。2016年 GopherCon。2016年8月18日。</summary>
    <p><b>总结：</b> 在 GopherCon 2016 视频节目“Go 汇编器的设计”中，Rob Pike 讨论了汇编语言对程序员的重要性。他解释说，汇编语言允许程序员在最低级别访问系统功能并优化性能。对于引导环境和利用硬件功能等任务来说，这是必要的。 Pike 强调，了解汇编语言可以更深入地了解计算机的工作原理。 Pike 接下来讨论了汇编语言的结构，重点介绍了标签、指令、操作数和注释等常见功能。他解释说，大多数 CPU 都有类似的结构，允许通用的语法。 Pike 还提到了为所有机器开发通用语法以及 Ken Thompson 在开发 C 编译器方面所做的工作。该视频节目深入探讨了 Go 编程语言中汇编器和编译器的演变。 Pike 解释说，从 C 代码到 Go 实现的过渡始于创建一个名为 Liblink 的库，从而加快了构建速度。 Go 编译器和链接器发生了重大变化，过时的结构选择被移至编译器和汇编器的后端。旧的 C 源代码已被翻译成 Go 程序，并且标签已被重写为一套库。 Pike 建议用用 Go 编写的单个程序替换所有汇编器。他讨论了在编译器中使用 -S 标志来显示汇编程序指令，并解释说生成的指令是来自编译器 stat 阶段的伪指令。 Pike 强调了使用通用汇编语言更容易编程和可移植性的优点。 该视频节目还介绍了新汇编程序的开发，该程序可以通过将输入语言解析为二进制形式来组装任何机器。 Pike 解释了汇编程序中文本处理的过程以及所使用的验证和测试方法。他描述了一种通用汇编器的开发，该汇编器消除了对硬件手册的需要，并用一个程序代替了多个程序。该汇编器与旧的汇编器兼容，并且可以处理多种体系结构。 Pike 最后提到了机器生成的反汇编程序的使用和逆向工程的挑战。目标是拥有一个可以与不同架构一起使用的机器生成的汇编程序，使开发人员更容易。他描述了使用 C 编程语言开发汇编程序的过程，并发现它令人兴奋且相对容易。总的来说，视频节目提供了有关 Go 汇编器的设计和演变的宝贵见解，强调了汇编语言的重要性以及通用汇编语言对编程和可移植性的好处。</p></details>
  + [talk/rob2016b](https://www.youtube.com/watch?v=sDTGhIqyMjo) <details><summary>标识堆栈：接口学习。悉尼 Go 集会。2016年9月19日。</summary>
    <p><b>总结：</b> 在悉尼 Go 聚会的这一集中，Google 杰出工程师 Rob Pike 讨论了使用界面来解决特定问题。他强调了设计、可移植性和生成手册的重要性。 Pike 探讨了词法分析器从输入中提取标记的作用，以及将用 C 编写的汇编语言代码转换为新汇编程序的挑战。他还讨论了新 C 编译器的实现及其对讲座的影响，强调了其使用汇编语言程序和定义常量、宏和指令的能力。然后，Pike 深入研究了 C 预处理器的特性和功能，包括启用和禁用代码块，以及用于分析 C 编程中的宏定义的令牌读取器的概念。他概述了 Go 编程语言中的令牌读取器和堆栈，解释了如何使用令牌读取器处理文件和包含内容，以及如何将它们实现为堆栈。 Pike 讨论了从堆栈中推送和弹出令牌读取器以及检索堆栈顶部的过程。他还在文中提到了堆栈的实现以及构建文本处理器的整体过程。此外，Pike 还解释了解析器中输入的概念以及需要额外的部分来处理解析器顶层的特定任务。他概述了 C 预处理器及其各个组件，包括解析和调用宏、防止无限递归以及使用哈希函数确定标记类型。派克强调将问题分解为简单组件并将它们组合起来解决复杂问题的好处。他还讲解了文件包含的过程、宏定义以及输入的重要性。 接下来在预处理器中。在整个剧集中，派克反思了他设计和实现解析器和汇编器的经验。他讨论了构建程序以通过所有部分实现一个接口以及使用 Graco 接口来解决问题的好处。 Pike 赞扬了堆栈的简洁结构以及技术扫描仪包在促进实施过程中的作用。他还讨论了使用汇编代码的挑战以及彻底测试的重要性。 Pike 提到了使用并发扫描器进行词法处理以及他编写 C 预处理器的经验。总的来说，这一集提供了有关使用接口、词法分析器、令牌读取器和堆栈来解决复杂编程问题的宝贵见解。 Pike 的专业知识和经验在他分享设计和实现高效解析器和汇编器的知识和实用技巧时表现得淋漓尽致。</p></details>
  + [talk/rob2017](https://www.youtube.com/watch?v=ENLWEfi0Tkg) <details><summary>Upspin 项目。2017 年 Gopherfest。2017年6月22日。</summary>
    <p><b>总结：</b> 在 Gopherfest 2017 的这一集中，Rob Pike 讨论了 Upspin，这是一个实验项目，旨在创建一个安全且统一的框架，用于在全球范围内命名和共享文件和数据。该视频首先强调了现代世界中管理个人数据的挑战，在现代世界中，下载和共享数字媒体通常意味着租赁，如果帐户丢失，则可能会失去访问权限。探讨了数据管理的历史，重点是向云存储的转变。人们表达了对当前数据所有权状态的不满，并强调了对 Upspin 这样的系统的需求。 Upspin 被描述为一个用于存储和组织数据、优先考虑个人隐私、安全和数据所有权的全球空间。与 Dropbox 等平台不同，Upspin 不适用于企业，旨在提供一个安全的数据存储系统，允许特定人群访问。该视频深入探讨了 Upspin 的技术方面，解释了它使用 Go 编程语言，并简要概述了所涉及的基础设施。该系统使用电子邮件地址作为用户名进行验证，并利用端到端加密来确保只有授权个人才能访问数据。 Upspin 树中的共享方式可以让您轻松了解谁可以访问共享内容。引入Go Centric模型，由密钥服务器、存储服务器和目录服务器组成，作为Upspin的基础。密钥服务器存储用户数据，存储服务器允许用户基于引用检索和存储数据，目录服务器处理二阶查找。 讨论了 Upspin 文件系统、其设计决策和组件，包括存储服务器、目录服务器和客户端库。该视频还探讨了 Upspin 的潜在应用，例如安全地访问托儿所摄像机中的数据或共享 iTunes 库。强调了现代世界安全、便捷的信息访问的重要性。总体而言，Upspin 旨在为用户提供对其数据的细粒度控制以及跨多个设备的统一计算体验。该项目处于早期开发阶段，鼓励用户输入以改进功能。虽然仍有一些需要改进的地方，例如文档和设计，但 Upspin 与其他全局文件系统的区别在于允许目录服务器和存储服务器是单独的机器。视频最后提到了 Keybase，这是一家提供安全数据访问和共享的云提供商，及其与各种平台的集成，以实现一致的访问、隐私和安全。</p></details>
  + [talk/rob2018a](https://www.youtube.com/watch?v=_2NI6t2r_Hs) <details><summary>Unix 历史。2018年11月7日。</summary>
    <p><b>总结：</b> 在这一集标题为“Unix 的历史”的视频中，Rob Pike 带我们踏上了计算演进和 Unix 发展之旅。作为该领域的内部人士，派克提供了塑造现代计算世界的关键部分的个人描述。 Pike 首先讨论了计算的早期阶段，当时使用的是打孔卡，而 Unix 的开发仍处于起步阶段。他分享了他使用 IBM 计算机的经验以及他对光线追踪和设计光学系统的迷恋。派克反思了该技术的可靠性以及他获取更多资源的决心。接下来，Pike 深入研究了 PDP-11 机器，重点介绍了其各种组件和功能，例如磁带驱动器、光盘架和图形奇迹。他还提到了图形处理的挑战和帧缓冲区的重要性。派克提供了对机器可见组件和早期计算的见解。 Pike 随后讲述了他将 Unix 系统引入加州研究生院并使用它来运行 Voyager 地面站的经历。他反思了跨越美国边境进口软件的挑战以及将扇形折叠转化为拍照手机的重要性。 Pike 还讨论了他在 Google 的早期工作，专注于图形和声音项目，并在少量内存上运行实验室。该视频节目还涉及 20 世纪 80 年代 Pike 在贝尔实验室的时光，他在那里从事有趣的项目，例如心脏模拟和 Multix 操作系统的开发。派克偶然发现了一台 PDP 7 计算机并创建了太空战争计划，为早期计算机游戏提供了深入的了解。 在整个剧集中，Pike 强调了 Unix 的重要性及其对计算世界的影响。他讨论了操作系统的演变以及他在 Unix 上学习编程的经历。派克还强调了图形和网络在计算技术发展中的重要性。总的来说，这一集让我们对 Unix 的历史以及 Rob Pike 作为计算机编程领域关键人物的旅程有了一个精彩的了解。</p></details>
  + [talk/rob2018b](https://www.youtube.com/watch?v=RIvL2ONhFBI) <details><summary>Go 2 规划草案。悉尼 Go 集会。2018年11月13日。</summary>
    <p><b>总结：</b> 在 Rob Pike 主持的 Sydney Golang Meetup 视频节目中，重点是 Go 2 的草案规范。该节目涵盖了与 Go 编程语言相关的广泛主题，包括其受欢迎程度、演进的必要性以及改进建议。该视频强调了 Go 稳定性和兼容性的重要性，这使得开发人员能够专注于编写代码而不是语言本身。然而，为了覆盖更多受众并解决某些问题，该语言需要在不影响兼容性的情况下不断发展。 Go 团队一直在参与讨论和设计草案，以探索该语言的潜在改进和变化。这些设计草案是产生想法和收集反馈的一种方式，目的是在进行增强的同时确保兼容性并最大限度地减少对现有代码的干扰。本集中讨论了具体的建议，例如使用名为“check”的新关键字来简化错误处理、简化变量声明以及引入函数本地错误处理机制。这一集还强调了错误处理中更好的语义和标准化的重要性，以及在软件包中拥有标准错误格式的重要性。本集还探讨了 Java 中参数多态性（也称为泛型）的概念。讨论了实现此功能时面临的挑战以及寻找解决方案的持续努力。这一集强调了在编程中能够在不同类型的数据之间进行排序和通信的重要性，以及动态类型检查和反射的缺点。 这一集还涉及了契约在编程中的重要性、调试工具 Delve 在 Go 社区中的作用，以及面向对象语言中协变和逆变的概念。在整个节目中，强调了语言设计和软件工程中协作和开放思想的重要性。讨论了设计 Go 编程语言所涉及的协作努力，强调了多个人的贡献以及达成共识的重要性。总之，由 Rob Pike 主持的悉尼 Golang Meetup 视频节目全面概述了最近围绕 Go 编程语言的讨论和建议，特别关注 Go 2 的概念。该节目强调了语言在保持兼容性的同时不断发展的必要性，并讨论了与错误处理、参数多态性和契约相关的具体建议和挑战。还强调了语言设计和软件工程中协作和多元化观点的重要性。</p></details>
  + [talk/rob2019a](https://changelog.com/gotime/100) Rob Pike 和 Robert Griesemer 创建 Go 语言。2019年9月10日。
  + [talk/rob2019b](https://www.youtube.com/watch?v=oU9cfQCxjpM) <details><summary>Rob Pike，Go 语言简史。2019年12月12日。</summary>
    <p><b>总结：</b> 在本期 GolangSyd Meetup 中，Rob Pike 于 2019 年 12 月 12 日发表了题为“A Brief History of Go”的演讲。演讲视频可以在 YouTube 上找到，并且音频经过了增强，以提供更好的聆听体验。不幸的是，演讲的幻灯片不可用。 Pike 在演讲中回顾了 Go 编程语言的起源和发展。他讨论了创建该语言所面临的挑战，并强调了它的成功和持续更新。 “Go”这个名字源自“Google”的前两个字母，强调该语言与公司的联系。 Pike 还探讨了个人在组织会议和分发软件方面的协作努力，展示了该语言在两年内的进步。他提到 2013 年 4 月举行的一次重要会议对 Go 的推广起到了至关重要的作用。还讨论了 go 雕像的演变和流行。派克提到了它们的分布及其在中国的特殊吸引力。他重点介绍了 Renee 精心设计的雕像和 2016 年发布的强大雕像。此外，他还提到了一个与语言相关的项目的启动。强调了管理和部署中首选流程的重要性。 Pike 解释了使用缓存版本进行更快测试的好处，并介绍了关于语言更改的三个建议。他还提到了与这些提案相关的意外惊喜。本集庆祝 Open Source Police 成立 10 周年，该社区拥有 115, 000 名成员。派克强调了提案制定过程、提案缩减以及已开展的各种社区项目。 他对所获得的支持表示感谢，并反思了该项目早期面临的挑战。派克承认在项目开始时管理社区存在困难，但对已取得的进展表示乐观。他从一开始就强调有效社区管理的重要性。总的来说，本集全面概述了 Go 编程语言的发展和改进。 Pike 的见解和反思为创建和管理编程语言的挑战和成功以及社区参与和协作的重要性提供了宝贵的见解。</p></details>
  + [talk/rob2020](https://evrone.com/rob-pike-interview) 一次 Rob Pike 采访。2020年4月30日。
  + [talk/rob2021](https://www.youtube.com/watch?v=YXV7sa4oM4I) <details><summary>Go 编程语言和环境。John Lions 卓越的演讲，新南威尔士大学。2021年5月27日。</summary>
    <p><b>总结：</b> 在这个题为“Go 编程语言和环境”的视频节目中，最后一位预定的演讲者因病无法出席。然而，谷歌工程师、Go 编程语言的联合创始人 Rob Pike 却站出来发言了。派克对能够以虚拟方式出席表示感谢，并表达了他对约翰·里昂斯的钦佩，约翰·里昂斯对他的职业生涯产生了重大影响。他还提到了与里昂斯和一位名叫伊恩·约翰斯顿的澳大利亚人的相遇如何引导他进入贝尔实验室并最终来到澳大利亚。 Pike 随后深入研究了 Go 编程语言的成功。 Go 最初不受欢迎，但由于它能够解决其他语言面临的挑战，因此在云计算中广受欢迎。它提供可扩展性、安全性、性能和自动化。该语言的成功可归因于其可靠的库、长期稳定性和更好的软件编写能力。 Go 的设计考虑到了可扩展性，重点关注并发和多核 CPU。软件开发的挑战之一是缺乏多核语言和协调大规模计算集群。由于 C++ 和 Java 等语言的复杂性和编译速度慢，构建它们的工具可能很困难。 Pike 讨论了 Google 如何过渡到新的构建系统，通过更精确地指定依赖关系来减少二进制大小。该视频节目全面概述了 Go 编程，涵盖 Web 服务器结构、接口、并发性和构建速率限制器等主题。它解释了 Go 如何利用映射和数组等简单机制来弥补参数多态性的不足，从而实现不同实现之间的兼容性。 Go 中接口的重要性也被强调，强调它们的简单性和灵活性。 Pike 进一步讨论了 Go 如何引入 goroutine 来实现高效的并行性和并发性，以及如何使用通道和 select 语句进行通信和同步。强调了 Go 编程的简单性和安全性，以及构建具有内置功能的库的重要性。 Go 的安全功能（包括无指针算术和索引检查）为其赢得了安全语言的声誉。该视频节目还谈到了 Go 的项目结构（称为 GOPATH）到当前模块系统的演变，及其对程序推理的影响。 Pike 表达了他对通道包和多路复用器等附加语言功能的渴望，以及试图使网络和通道协同工作时面临的困难。总的来说，这一集强调了 Go 编程语言的成功和优势，包括它的兼容性、性能和强大的库支持。 Pike 强调了协作和代码共享对于创建繁荣的软件开发生态系统的重要性。本集最后，派克对未能出席的参与者表示感谢，并提到了即将举行的会谈。</p></details>

- Robert Griesemer（博士）[GitHub](https://github.com/griesemer), [Twitter](https://twitter.com/robertgriesemer?lang=en)
  + 毕业院校：苏黎世联邦理工学院
  + [paper/robert1993](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.127.5290&rep=rep1&type=pdf) 矢量计算机编程语言。博士论文。1964年6月9日。
  + [talk/robert2012a](https://www.youtube.com/watch?v=on5DeUyWDqI) <details><summary>E2E: Erik Meijer 和 Robert Griesemer。Lang.NEXT Going Go。2012年3月16日。</summary>
    <p><b>总结：</b> 在本期 E2E 中，Erik Meijer 采访了 Go 编程语言的设计者 Robert Griesemer。 Go 是一种并发、垃圾收集的系统编程语言，具有快速编译的特点。对话涵盖了与 Go 及其作为母语的适用性相关的各种主题。讨论从 Go 是否是母语的问题开始。 Griesemer 解释说，Go 可以编译为本机代码并具有脚本功能，使其成为本机开发的通用语言。他强调了使用 Go 的优势，例如快速编译和执行，以及名为“bill”的新构建工具，可简化开发过程。然后，对话深入探讨了编译器在编程中的重要性。 Griesemer 解释说，更快的启动时间和代码优化是使用编译器的主要好处。他还探讨了用于优化 JVM 启动时间的技术以及使用本机语言和本机编译的二进制文件的好处。 Go 中的错误处理哲学是另一个讨论的话题。 Griesemer 强调了处理错误而不是忽略错误的重要性，并解释了 Go 如何通过其多返回值功能来简化错误处理。他还讨论了错误处理的不同方法，包括使用特殊错误类型和恐慌，并强调需要单独处理异常情况，而不是使用异常处理作为控制流机制。还探讨了接口在面向对象编程中的重要性，特别是在 Go 中。 Griesemer 解释了 Go 如何允许方法附加到各种类型以及如何使用接口类型作为方法的规范。 他认为实现继承可能被高估了，嵌入另一种类型可以达到类似的结果。 Go 编程语言提供了转发和委托的原语，允许开发人员自己构建这些概念。围绕在编程语言中包含泛型的争论，特别是在 C++ 环境中，是讨论的另一个主题。 Griesemer 承认泛型的好处，例如改进的代码可重用性和类型安全性，但也承认它们带来的挑战，包括与现有语言功能的集成。他讨论了使用模板的权衡和挑战，并探索了泛型的替代方法。对话最后讨论了 Go 例程，这些例程是 Go 中的轻量级线程，为并发提供了强大的支持。 Griesemer 解释了它们的实现和用例，以及使用 Go 例程之间通信通道的好处。总的来说，这次对话提供了有关 Go 编程语言的设计和功能的宝贵见解，使其成为对 Go 和本地语言开发感兴趣的开发人员的必听之选。</p></details>
  + [talk/robert2012b](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012/Go-In-Three-Easy-Pieces) <details><summary>Go 的三个简单部分。2012年3月19日。</summary>
    <p><b>总结：</b> 在题为“Lang NEXT 2012 Go In Three Easy Pieces”的视频节目中，演讲者讨论了 Go 编程语言的各个方面。他们强调其简单性、紧凑的尺寸和强大的并发支持，这使其在开发人员中越来越受欢迎。本集首先解释了 Go 的独特功能，例如高效的实现、强大的标准库和一系列开发工具。该语言强调可理解性和简单性，使开发人员更容易理解和编写代码。它还具有不同的异常处理和面向对象编程方法，允许在没有类的情况下定义方法，并提供对并发的内置支持。然后演讲者深入探讨了 Go 中的字符串方法和类型兼容性主题。他们解释了如何使用点表示法和静态调度来使用字符串方法，并讨论使用它们的优点。他们还讨论了显式转换，特别是在数字类型的上下文中。本集介绍了接口及其有效组合软件的能力，并举例说明了动态调度和即插即用兼容性。强调了在编程中使用接口的好处，例如灵活的代码重用以及无需修改即可与代码交互的能力。还讨论了设计对象层次结构和实现接口的挑战。接下来，演讲者讨论了在 HTTP 应用程序中使用文件处理程序以及使用 Ingo 来呈现下颌骨图像。他们解释了具有图像各种属性的结构的实现以及用于生成它的方法。该剧集还提到了使用库函数将图像编码为 PNG 文件。 此外，演讲者还讨论了如何使用闭包生成器通过测量任务执行时间来分析 Mandelbrot 服务器的性能。本集随后重点介绍了 Go 编程语言的速度和效率。它解释了 Go 如何通过垃圾收集等功能快速安全地运行代码。讨论了使用 go 例程和通道来实现轻量级和灵活的代码实现。通道用于 Go 例程之间的通信和同步，无需手动同步。演讲者还讨论了使用通道和闭包的典型 Go 并发模式，以及用于高效任务执行的工作调度程序的概念。解释了将顺序代码转换为并发代码的过程，强调了更快计算和加速的好处。本集最后讨论了 Go 中的延迟语句，它允许在执行主体之前启动和暂停函数。还解释了 Go 中用于异常处理的恐慌和恢复机制。提到了Go的推出，强调了它的稳定性和向后兼容性。还提到了 Go 在初创公司中的使用及其在 App Engine 上的可用性。本集最后强调了语言支持在 Go 中提供有效并发支持的重要性。</p></details>
  + [talk/robert2012c](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012/Panel-Native-Languages) <details><summary>2012年 Lang.NEXT 专家组：原生语言。2012年4月11日。</summary>
    <p><b>总结：</b> 在题为“Lang NEXT 2012 专家小组：本机语言”的视频节目中，专家小组讨论了本机代码编程的优点和局限性。小组成员分享了他们的经验和偏好，其中一些人喜欢本机代码的速度、效率和控制。他们强调针对每种情况使用最有利的机制的重要性，并将其与针对特定任务选择编程语言进行比较。小组成员讨论了本机代码执行的好处，例如优化的用户体验以及与硬件密切合作的能力。他们还强调直接调用 C 代码的能力是本机代码的主要优势。然而，他们承认虚拟机 (VM) 实施存在潜在问题。小组成员还探讨了本机代码和托管代码的优点和缺点。本机代码提供速度和控制，而托管代码允许在加载时进行高级处理。两者之间的选择取决于应用程序的最大成本。小组成员讨论了母语在实现互操作性和语言设计方面面临的挑战。他们提到了 Google 和 Facebook 等公司开发的互操作性协议。该小组对这一领域的研究进展以及即插即用兼容性通用接口的重要性表示乐观。该视频还强调了 Facebook 后端开发从 PHP 到 C++ 的转变。这一变化是由对更高效的功耗和改进的性能的需求推动的。使用 C++ 可以更有效地利用每个用户的能力，并可以开发高性能广告。 小组成员讨论了软件设计中程序生产力和性能之间的权衡。他们强调预防胜于治疗的重要性以及管理语言和母语采取的不同方法。还强调了在网络世界中维护一致数据库的重要性。该视频最后讨论了编程语言的复杂性和内存管理的挑战。小组成员提到需要进行研究以确定最复杂的语言规范，并强调内存管理安全性和效率之间的权衡。总的来说，这一集强调了使用适当的编程语言来完成特定任务并及时了解该领域进展的重要性。小组成员深入探讨了本机代码编程的优点和局限性以及行业的持续发展。</p></details>
  + [talk/robert2015](https://www.youtube.com/watch?v=0ReKdcpNyQg) <details><summary>Go 的演变。2015年 GopherCon，2015年7月28日。</summary>
    <p><b>总结：</b> 在题为“GopherCon 2015：Robert Griesemer - Go 的演变”的视频节目中，Robert Griesemer 讨论了 Go 编程语言的演变。 Griesemer 首先分享了他在编程语言方面的背景，包括在 Pascal 的创建者的指导下学习。他反思了创建良好的编程语言所面临的挑战以及在职业生涯中保持生产力的困难。在使用 C++ 编程 15 年后，Griesemer 决定启动一个新项目来创建一种更好的语言。他强调了语言设计中简单性、安全性和可读性的重要性。 Griesemer 认为这些原则对于创建易于使用且易于理解的语言至关重要。他还讨论了语言设计中涉及的决策过程以及使编程的某些方面易于编写的重要性。 Griesemer 提到缺乏有关语言设计的文献，但推荐了 Tony Hoare 的两篇论文。他还讨论了头脑风暴的过程以及语言设计中指导和协作的重要性。该视频剧集探讨了编程语言的演变，重点关注 Pascal 的后继者和编程语言 Oberon。 Griesemer 强调了 Pascal 和 C 之间的异同，以及 Modula-2 和 Oberon 等语言中新功能的引入。他还讨论了 Go 和 Oberon 编程语言之间的相似之处，强调它们在 Oberon 中的共同起源以及 C 对 Go 的影响。随后，Griesemer 深入研究了 Go 编程语言的开发，强调了其源于 Oberon 以及面向对象的结合。他从 Smalltalk 中汲取灵感，强调了 Go 中面向对象和接口的重要性。 Griesemer 还讨论了 Go 中的动态调度和泛型的缺失，解释了挑战以及 Go 团队优先考虑现有机制的决定。该团队仍在评估引入仿制药的影响。 Go 编程语言的开发涉及彻底的测试过程和小创建团队之间的情感讨论。 Ross Cox 的加入改进了开发过程，多个独立的实现揭示了编译器和规范中的错误。 go types 包的包含进一步验证了代码。该语言发生了重大变化，形成了更强大的语言，并具有易于调整和向后兼容性的工具。基于明确的目标、可用的库和工具、市场准备情况、技术突破和独特的功能，Go 的未来看起来充满希望。视频节目最后质疑 Go 是否会成为主流，并提到统一 Go 社区的必要性。它还讨论了语言设计中的陷阱、编程语言的历史以及它们如何反映其创造者。本集好奇新语言Co能否成功。</p></details>
  + [talk/robert2016a](https://www.youtube.com/watch?v=t-w6MyI2qlU) <details><summary>和 Gom 的简单对话：声明别名（建议）。2016年 GopherCon，2016年10月9日。</summary>
    <p><b>总结：</b> </p></details>
  + [talk/robert2016b](https://www.youtube.com/watch?v=vLxX3yZmw5Q) <details><summary>为你的设计做原型！2016年 dotGo，2016年11月29日。</summary>
    <p><b>总结：</b> 在题为“dotGo 2016 - Robert Griesemer - 为您的设计制作原型！”的视频节目中，Robert Griesemer 讨论了原型设计在软件设计中的重要性。他解释了原型设计如何为现有设计提供信息并带来更好的最终设计。 Griesemer 首先强调了软件开发过程中设计阶段的重要性。他提到斯坦福大学的五步设计流程作为设计和原型制作在各个行业中的重要性的例子。他强调设计师不仅是思想家，也是实践者。本集的主要焦点是语言设计，特别是 Go 编程语言中的多维切片支持。 Griesemer 解释说，Go 社区一直致力于寻找二维索引的解决方案，但这仍然是一个挑战。他提出了一种通过多维索引来提高 Go 的可读性和性能的解决方案。为了实施这一提议，Griesemer 强调了重写器原型的重要性。该原型允许分析设计选项并避免对编译器进行大幅更改。为了清楚起见，他解释了如何使用特殊方法名称和加号运算符将索引表达式手动或自动重写为方法调用。 Griesemer 讨论了用 Go 编程语言重写和修改代码的过程。他解释了如何通过调用特定方法来赋予新索引表达式含义。他还提到了重写语法树而不是源代码的重要性，因为它允许以最少的代码修改对现有库进行更改。本集还涉及使用 Go 类型检查器来提高语言的准确性和效率。 Griesemer 解释了重写二进制加法如何解决缺失的类型并作为实验和改进原型的核心。在整个剧集中，Griesemer 强调了测试和完善设计的具体实施的重要性。他强调了有效指数运算符的惊人发现，并质疑它们是否足以解决某些问题。他最后重申了原型设计在编程中的价值。总之，视频节目探讨了原型设计在软件设计中的重要性，特别是在 Go 编程语言中多维切片支持的背景下。 Griesemer 讨论了重写和修改代码的过程，以及使用 Go 类型检查器来提高准确性和效率。他强调了具体实施的重要性以及原型设计在告知和改进最终设计中的作用。</p></details>
  + [talk/robert2017](https://www.youtube.com/watch?v=KPk1UPihWtY) <details><summary>开幕演讲：导出 Go。2017年 GopherCon SG，2017年5月29日。</summary>
    <p><b>总结：</b> 在 GopherCon SG 2017 的开幕主题演讲中，Robert Griesemer 讨论了 Go 编程语言及其使用包来划分大型项目。他将包的导出和导入机制与 20 世纪 70 年代 C 语言发明时的简单时代进行了比较。 Griesemer 强调了使用头文件在 C 语言中创建库的重要性，因为它们允许显式声明库接口，使 C 编译器更容易编译程序。然而，他也承认使用头文件的局限性和挑战，例如大型系统中的信息泄漏和潜在的性能问题。 Griesemer 解释说，包序列化在编程语言中很重要，因为它允许编译器理解和传达导入的包。他讨论了编译 Go 包的过程和序列化的必要性，以及使用 dot o 和 dot a 文件导出和导入数据。他提到可以使用文本编辑器读取目标文件，并解释了 pre-1 的结构和内容。 7 编译器目标文件，其中包含冗余和不必要的信息。为了解决这些问题，Griesemer 解释说，采用了更紧凑、更高效的二进制导出格式。新格式还包括附加信息，并且无需成熟的解析器即可轻松扩展。他讨论了 Go 中包接口的序列化，其中涉及将内部数据结构表示为图形。 Griesemer 解释了 Go 中的序列化算法，该算法可用于任何图形数据结构，包括为节点分配唯一的整数值并写出其内容。 Griesemer 强调需要通过重新设计索引来有效处理出口数据，从而减少处理浪费。他讨论了文本导出格式和二进制导出格式之间的差异，其中二进制格式更节省空间。然而，在仅处理所需字段方面仍然存在挑战。 Griesemer 建议重新设计导出数据，使其可索引，以便更有效地访问，特别是对于协议缓冲区等大型数据结构。总的来说，Griesemer 的主题演讲深入了解了 Go 中导入和导出机制的内部工作原理，以及这些机制如何实现健壮的包单独编译。他讨论了这些机制的历史背景以及影响可扩展性的设计权衡。演讲强调了包序列化的重要性以及创建高效、紧凑的导出格式所涉及的挑战。</p></details>
  + [talk/robert2017](https://www.youtube.com/watch?v=UmwJsQTSEP8) <details><summary>Go 的概述。2017年8月28日。</summary>
    <p><b>总结：</b> 在本期视频中，Go 编程语言的设计者之一 Robert Griesemer 简要概述了 Go 及其主要功能。他首先解释说，Go 是由 Google 开发的，作为 C++ 的替代品，自发布以来已经取得了巨大的成功和增长。它受到开发者的高度重视，拥有500、000到100万用户。 Griesemer 强调了 Go 的紧凑性、可读性和简洁性，以及它的垃圾收集功能和对并发的支持。他提到 Google、IBM、微软和 Uber 等大型科技公司，以及《纽约时报》、BBC、亚马逊和沃尔玛等公司都使用 Go。它也是中国发展最快的语言之一。讨论了 Go 的独特功能，包括常量声明和强大的复合文字构造函数。 Griesemer 解释了脚本语言的简化语法和强大的构造函数，以及函数作为一流对象和闭包的使用。他展示了一个数学矩阵乘法示例来展示 Go 的简单性和效率。还解释了没有类或继承的面向对象语言中的方法和接口的概念。 Griesemer 解决了缺乏对多维矩阵的支持的问题，并提供了一种解决方法。他还提到了编程中的动态调度。介绍了并发编程中goroutine和channel的使用。 Go 中的通道用于 goroutine 之间的通信和同步，允许在不共享内存的情况下进行高效通信。 Griesemer 讨论了 Go 中如何使用通道来实现 goroutine 之间的高效通信，强调了它们在内存使用和通信方面的成本效益和效率。然后作者探讨了并发在矩阵乘法中的使用。他们讨论了使用并发重写代码的实验，并解释了 goroutine 和等待组的使用。还讨论了传统乘法和并发乘法之间的性能差异。进一步讨论了 Go 的特性和优点，包括它的标准库、平台独立性和操作该语言的工具。重点介绍了用 Go 编写 HTTP 服务器的简便性及其在容器化和云环境中的受欢迎程度。文本最后提到了 Co 编程语言的工具和功能，以及使用 C++ 和 Go 进行科学计算的挑战。 Go 编程语言拥有活跃的社区和广泛的库，在全球范围内越来越受欢迎并定期举行会议和聚会。社区正在致力于改进依赖管理、用户体验和包容性，目标是使 Go 成为云系统的首选语言。</p></details>
  + [talk/robert2019](https://www.youtube.com/watch?v=i0zzChzk8KE) <details><summary>Go 10岁了！现在咋样？2019年 Gopherpalooza。2019年12月2日。</summary>
    <p><b>总结：</b>在题为“Go is 10! Now What?”的视频剧集中由 Go 编程语言的创建者之一 Robert Griesemer 撰写，他回顾了 Go 的 10 周年，并讨论了其发展里程碑和未来计划。格里塞默首先承认围棋在过去十年中的发展和成功。他强调了在世界各地举办的众多会议和聚会的蓬勃发展的社区。根据 2019 年 JetBrains 开发者调查，Go 是第三大最想学习的语言，超过三分之一的开发者计划在 2019 年学习它。 Pound 和 Capital One 等公司称赞 Go 的简单性、强类型、并发支持、垃圾收集和快速编译时间。出于对现有语言的不满，Go 的开发于 2007 年开始，两年后公开发布。 Griesemer 讨论了项目首次公开发布的过程，包括谈判、决策和做出变更。尽管存在潜在的失败，该项目还是成功发布，引起了积极和热烈的反响。格里塞默还强调了明确的目标、扎实的想法和外部投入对于项目成功的重要性。他反思了他们的第一个孩子出生后面临的挑战，并指出了明确的目标和外部投入对项目成功的重要性。 Go 编程语言的演变是本集中讨论的另一个主题。 Griesemer 强调了兼容性保证的重要性及其对采用的影响。他还强调了对社区建设和影响语言方向的提案流程的关注。 提到了对 Go 所做的谨慎和渐进的改变，包括可选的分号和新函数的引入。详细讨论了提案流程本身，概述了一个简单的四步流程，包括 GitHub 问题、讨论、设计文档和代码团队的最终决定。格里塞默强调需要编写良好的提案来解决重要问题、影响最小并提供明确的解决方案。他还提到了提案审查的引入以及对现有代码影响的考虑。展望未来，Griesemer 提到了 Go 团队的目标，其中包括模块支持以及打破模块向后兼容性的可能性。该团队计划进行 API 更改，重点关注泛型和模块支持，并随着语言的成熟提供更多社区贡献。总之，视频节目提供了有关 Go 编程语言 10 年历程的宝贵见解。它强调了其成长、成功以及一路上面临的挑战。 Griesemer 对 Go 的反思和未来计划表明了团队对持续改进和社区参与的承诺。</p></details>
  + [talk/robert2020a](https://changelog.com/gotime/140) 泛型最终版：Robert Griesemer 和 Ian Lance Taylor。2020年7月21日。
  + [talk/robert2020b](https://www.youtube.com/watch?v=TborQFPY2IM) <details><summary>编写 Go（泛型）。2020年11月11日。</summary>
    <p><b>总结：</b>在题为“GopherCon 2020：Robert Griesemer - Typing [Generic] Go”的视频节目中，Robert Griesemer 讨论了 Go 编程语言中泛型的最新进展。本集首先介绍泛型的概念及其在提高 Go 类型安全性、效率和性能方面的重要性。 Griesemer 解释说，Go 中泛型的设计草案引入了类型参数和约束的概念。这些类型参数简化了设计并确保向后兼容性。他接着讨论了如何在函数参数列表中使用类型参数和约束，并提供了标准库中通用 API 的具体示例。还解释了在 Go 中实现泛型的动机，Griesemer 强调了类型安全的需求以及在不牺牲性能的情况下处理不同类型的能力。他讨论了约束的概念以及如何将它们实现为接口以确保类型安全。本集深入探讨了 Go 中泛型函数和类型参数的细节。 Griesemer 解释说，类型参数在整个函数中都是可见的，并且可以在所有参数列表中使用。他强调了满足类型参数施加的约束的重要性，并解释了实例化的过程，其中类型参数替换了函数签名中的类型参数。还介绍了 Go 中的类型检查和实例化，Griesemer 提供了实例化通用排序函数的示例。他讨论了在 Go 中使用泛型类型和类型参数的好处，但也承认需要约束来确保类型安全。 本集进一步探讨了泛型函数中类型参数推断的概念，讨论了匹配类型结构的过程以及类型统一的使用。 Griesemer 提到了类型推断的局限性以及提供所需方法的必要性。还解释了在 Go 中使用类型列表来编写可以处理不同类型（包括派生类型）的泛型函数。 Griesemer 引入了约束的概念，例如“有序”约束，它确保函数中使用的类型支持某些运算符。总的来说，本集全面概述了 Go 编程语言中泛型的进展。 Griesemer 强调了采用泛型的重要性，并强调了它们给 Go 带来的好处。 Go 团队正在积极致力于实现泛型，并欢迎社区的反馈。当前的设计是向后兼容的，并且非常适合现有的 Go 代码，但应谨慎行事，以避免不必要的复杂性并考虑潜在的缺点。</p></details>
  + [talk/robert2021](https://www.youtube.com/watch?v=Pa_e9EeCdy8) <details><summary>泛型! Dec 17, 2021.</summary>
    <p><b>总结：</b>在题为“泛型！”的 GopherCon 2021 视频节目中，Go 团队成员 Robert Griesemer 和 Ian Lance Taylor 讨论了即将发布的 Go 1.18 及其对泛型函数和类型的支持。它们强调了泛型为 Go 编程语言带来的表达能力以及有效使用它们所带来的责任。 Go 1.18 中的新功能包括类型参数、更强大的接口类型和改进的类型推断。这些功能消除了对类型参数的需要，使得在 Go 中使用泛型进行编程更加高效。此更新还引入了类型约束（定义参数的有效类型）以及定义方法集的接口。 Griesemer 和 Taylor 提供了有关何时何地使用 Go 中通用功能的指南。他们建议从函数而不是类型参数开始，并将类型参数用于对特殊类型进行操作的函数，而不需要对元素类型进行假设。与反射或接口类型相比，它们强调类型参数的灵活性和效率，允许通用数据结构和完全类型检查的代码。演讲者还讨论了理解元类型和使用接口作为通用函数约束的重要性。他们提到了语法糖的引入以及切片类型的类型参数的使用。它们还涉及类型推断及其在从类型参数约束推导类型参数中的作用。 Griesemer 和 Taylor 强调在使用泛型时需要保持 Go 代码的可读性、可维护性和良好的性能。他们建议当多种类型共享具有相同实现的通用方法时使用类型参数，并使用接口类型进行泛型编程和从任何值读取数据。 他们提到，在类型参数没有帮助的情况下可以使用反射。总体而言，即将发布的支持泛型的 Go 1.18 为该语言带来了显着的表达能力。 Griesemer 和 Taylor 就如何有效使用泛型提供了宝贵的指导，强调了根据代码的具体要求选择适当方法的重要性。通过遵循他们的建议，开发人员可以利用泛型的优势，同时保持代码的可读性、可维护性和性能。</p></details>
- Ken Thompson（Kenneth Lane Thompson 科学硕士）（退休）
  + 毕业院校: 加州大学伯克利分校
  + [talk/ken1982a](https://www.youtube.com/watch?v=tc4ROCJYbm0) <details><summary>UNIX 系统：提高计算机生产效率。1982年。</summary>
    <p><b>总结：</b>在 AT&T Archives 的这一集标题为“UNIX 操作系统”中，主持人兼旁白 Victor Vyssotsky 将我们带回到 20 世纪 60 年代末，当时贝尔实验室计算机科学家 Dennis Ritchie 和 Ken Thompson 开始了一个受 Multics 操作系统启发的项目。系统。 Ritchie 和 Thompson 的目标是为程序员创建一个更有用、更灵活、更便携的系统。众所周知，UNIX 系统通过提供由内核、shell 和有用程序组成的结构，彻底改变了软件开发。这种结构简化了交互并实现了高效的编程。只需几行代码，就可以创建各种应用程序，从而使 UNIX 系统具有极高的生产力和效率。 UNIX 系统的主要优点之一是它能够使用管道将不同任务的程序组合起来。该视频重点介绍了拼写检查程序的示例，该程序演示了如何利用现有的 UNIX 程序来识别句子中潜在的拼写错误。通过将句子拆分成单词，将它们与字典进行比较，将它们转换为小写，并按字母顺序排序，可以轻松识别和纠正拼写错误。 UNIX 系统还提供了大量预构建工具，并且能够轻松构建新工具。强大的模式匹配算法可以快速打包到UNIX程序中并与社区共享，进一步提高生产力和效率。该视频还深入探讨了操作系统的结构以及对更好的集成电路设计工具的需求。它介绍了 Steve Johnson 和他的程序 Elgin，该程序是为逻辑电路设计而开发的。 UNIX 系统以其独立的程序和分层目录结构，被证明是电路设计的宝贵工具。此外，视频还提到了 Dennis Ritchie 在 UNIX 系统开发过程中创建了 C 语言。 C语言允许程序员拥有更多的控制权并编写可以轻松移植到不同机器的操作系统。这进一步巩固了 UNIX 系统编程的普及性及其与其他语言的兼容性。总之，视频强调了计算机技术的发展以及对更加用户友好的设计工具的需求。 UNIX 系统以其适应性强和高效的特性，在软件开发中发挥了重要作用，并且仍然是程序员的强大工具。</p></details>
  + [talk/ken1982b](https://www.youtube.com/watch?v=XvDZLjaCJuw) <details><summary>UNIX 系统：提高计算机易用性。1982年</summary>
    <p><b>总结：</b>在题为“Unix 系统：使计算机更易于使用 - 1982”的视频节目中，主持人讨论了 UNIX 操作系统的发展和意义。该集针对的是对工程、数学、计算机科学和其他科学感兴趣的学生。它于 1982 年 12 月与另一部电影一起发行，该电影为计算机科学专业的学生和企业实习生提供了有关 UNIX 的更详细的讨论。主持人首先解释了应用软件和操作系统之间的区别，强调了操作系统在简化计算过程中的作用。它们重点介绍了 UNIX 的三个主要组件，并提供了一个实际使用它来查找拼写错误的示例。他们解释了将句子转换为单个单词、按字母顺序排序并将其与字典进行比较的过程。 “make Words”和“lowercase”等程序用于识别和纠正拼写错误。然而，主办方承认，某些词语（如行话和专有名称）可能不会被识别为错误。他们建议使用这些单词来改进词典，以便将来进行拼写检查。主持人还讨论了 UNIX 系统的生产力和灵活性。他们将其文件系统比作文件柜，可以轻松检索文件。文件格式的灵活性使编程更加容易，索引系统文件由程序员决定。 UNIX 可以轻松地在文件之间移动数据，并且能够使用任何程序处理任何文件。主持人强调了 UNIX 在管道技术方面的基本贡献，可以连接多个程序。本集演示了如何使用 UNIX 管道来查找拼写错误并创建一个会说话的计算器。 它提到了 UNIX 程序开发中现有工具的使用，并强调了 UNIX 实用程序在构建有价值的应用程序中的价值。主持人还提到了作家工作台的开发，包括校对程序，以改进文档。该程序分析书面文本的风格并提出改进建议。虽然 UNIX 在程序开发中发挥了重要作用并提供了预先存在的模块，但主办方承认需要进一步发展计算机技术以使其更加用户友好。总体而言，该视频节目全面概述了 UNIX 操作系统、其实际应用及其对计算领域的贡献。它强调了 UNIX 在简化计算过程、提高生产力和支持开发有价值的应用程序方面的重要性。</p></details>
  + [talk/ken1982c](https://www.youtube.com/watch?v=JoVQTPbD6UY) <details><summary>Ken Thompson 和 Dennis Ritchie 解释 UNIX（贝尔实验室）。1982年。</summary>
    <p><b>总结：</b>AT&T 贝尔实验室 (BTL) 宣传片中的片段（大约 1980 年代），由 UNIX 创建者 Ken Thompson 和 Dennis Ritchie 简要介绍了 UNIX 环境。在客串角色中，您会看到 UNIX 杰出人物 Greg Chesson（身穿酒红色衬衫）和 Doug McIlroy（前景为 Greg）。另外还有经典的 ASR-33 电传打字机、BLIT 显示器（由当时的实验室成员 Rob Pike 开发）等等。</p></details>
  + [talk/ken1998](https://www.youtube.com/watch?v=LXZ1OL2U3lY) <details><summary>Ken Thompson 和 Dennis Ritchie：国家技术奖章。1998年。</summary>
    <p><b>总结：</b>女士们、先生们，1998 年国家技术奖章获得者 1998 年国家技术奖章获得者来自贝尔实验室的 Kenneth L Thompson 和 Dennis M Richie 团队放松了技术，共同发明了 UNIX 操作系统和 C 编程语言，共同带来了计算机硬件软件和网络系统的巨大进步，并刺激了整个行业的发展，从而增强了美国在信息领域的领导地位。</p></details>
  + [talk/ken2013](https://www.youtube.com/watch?v=dsMKJKTOte0) <details><summary>系统架构、设计、工程和验证。2013年1月17日。</summary>
    <p><b>总结：</b>剧集标题：系统架构、设计、工程和验证 在这一集中，关于系统架构设计和验证的小组讨论由 Dahlia Malkhi 主持。该小组由该领域的专家组成，包括 Fernando J. Corbato、E. Allen Emerson、Joseph Sifakis 和 Ken Thompson。讨论探讨了计算机科学系统领域的研究与实践之间的关系。小组成员首先回顾了他们过去的获奖研究及其对计算世界的影响。他们强调算法在软件开发中的重要性以及人工智能的潜力。强调了简化计算和创建小型、简单操作系统的目标。小组成员还讨论了实施新解决方案和存储大量数字信息的能力所面临的挑战。讨论了图灵通用机对操作系统的影响以及他面临的挑战。还提到了计算中分时共享的演变和 Multics 操作系统的发展，因为它们对计算产生了重大影响。小组成员反思了早期计算系统的遗产及其对我们当今计算方法的塑造。他们提到了 2007 年图灵奖获得者，他们开发了模型检查作为一种有效的验证技术。讨论了模型检查的概念、表达性和效率的挑战以及反应式系统的重要性。强调了验证和系统设计的必要性，以防止错误和事故。小组成员还讨论了网络物理系统中严格系统设计的挑战和重要性。 他们呼吁采用一种方法来规范从需求到实施的过程，并强调当前系统开发流程缺乏一致性。强调了系统设计在计算机科学中的重要性以及研究界更多关注的必要性。该小组讨论了转型软件和反应式系统之间的差异，并提到了集成异构混合技术系统的挑战。他们还讨论了运气在计算机研究成功中的重要性以及系统构建中的协同作用。该小组最后讨论了操作系统（包括 UNIX 和 Linux）的未来，以及它们可能面临的挑战和创新。人们对计算机系统的复杂性以及在云中存储个人数据的风险的担忧凸显。强调用户需要了解云提供商的可靠性和可信度。总的来说，小组讨论为系统研究和工程实践之间的关系提供了宝贵的见解，强调了正确的系统设计、验证的重要性以及计算机科学中实际应用的需要。</p></details>
  + [talk/ken2019a](https://www.youtube.com/watch?v=g3jOJfrOknA) <details><summary>Thompson 和 Ritchie 的故事。2019年2月18日。</summary>
    <p><b>总结：</b>在这一集中的“突破技术极限：肯·汤普森和丹尼斯·里奇的故事”中，我们深入探讨了 Unix（肯·汤普森和丹尼斯·里奇创建的革命性操作系统）的突破性发展和持久影响。在 Unix 之前，计算机体积庞大且价格昂贵，但这种改变游戏规则的操作系统允许多任务处理和个人使用，永远改变了技术的面貌。本集首先介绍肯·汤普森和丹尼斯·里奇，这两位在贝尔实验室一起工作的才华横溢的人。他们决心创建一种替代当时主导计算机行业的批处理系统的方法。他们的合作导致了 Unix 的诞生，这是一种多任务、多用户操作系统，将彻底改变该领域。主持人分享了他们使用 Unix 的个人经历，强调了 Unix 在他们生活中所扮演的重要角色。他们回忆起能够在计算机上玩游戏的兴奋，这要归功于 Unix 的多任务处理功能。这个个人轶事有助于说明 Unix 对日常用户的影响，因为它允许个人使用和娱乐的规模以前是难以想象的。这一集还揭示了丹尼斯·里奇的非凡能力和奉献精神。他的数学能力和对工作坚定不移的奉献精神对 Unix 的发展起到了重要作用。 Ritchie 对计算机科学领域的贡献不容小觑，他与 Thompson 的合作是 Unix 成功的关键因素。在整个剧集中，汤普森和里奇之间的密切合作得到了强调。 他们共同的愿景和互补的技能使他们能够突破技术的界限，并创建一个将塑造计算未来的操作系统。他们在贝尔实验室的工作为我们今天依赖的现代技术铺平了道路。尽管 Unix 是几十年前开发的，但它的影响仍然存在于我们的日常生活中。本集最后强调了 Unix 的持久遗产及其对技术的持续影响。从我们使用计算机的方式到后续操作系统的开发，Unix 的影响是不可否认的。总而言之，本集“突破技术极限：肯·汤普森和丹尼斯·里奇的故事”探讨了 Unix（肯·汤普森和丹尼斯·里奇创建的突破性操作系统）的发展和影响。他们在贝尔实验室的合作创造了一个多任务、多用户操作系统，彻底改变了技术领域。 Unix 的持久遗产继续塑造着我们的日常生活，使其成为计算史上的一个关键里程碑。</p></details>
  + [talk/ken2019b](https://www.youtube.com/watch?v=EY6q5dv_B-o) <details><summary>Brian Kernighan 采访 Ken Thompson。2019 年 VCF East，2019年3月4日。</summary>
    <p><b>总结：</b>在这一题为“Ken Thompson 在 VCF East 2019 上接受 Brian Kernighan 采访”的视频节目中，UNIX 操作系统的联合发明人 Ken Thompson 接受了 Brian Kernighan 的采访。这一集发生于 2019 年 5 月 4 日，深入了解 Thompson 在贝尔实验室的旅程以及他对计算机科学领域的贡献。炉边谈话以老式计算机联合会 (VCF) 的介绍和最新动态开始。 Thompson 随后分享了他如何进入贝尔实验室，与 Dennis Ritchie 一起创建 UNIX。他回忆了 UNIX 的起源，并透露距离创建一个操作系统只有三周的时间。 Thompson 讨论了他们在开发 PDP-11 计算机时面临的挑战以及为 DC 移植和测试汇编语言的重要性。他重点介绍了磁盘和通信设备的引入，这促进了 UNIX 的快速发展。 UNIX 的重要贡献之一是管道的发明，允许进程之间进行通信。还探讨了进程间通信的演变，从无价值的接口到通过管道实现的突破性想法。讨论了重定向 IO 的开发和 shell 的创建，以及文件搜索工具 grep 的起源及其与 AT&T 口号的联系。该视频节目还深入探讨了编程语言的演变，从早期的 B Unbond 语言到目前的 Go 语言。 Thompson 称赞 PDB 7 计算机上的 TMG 编译器字迹优美且没有错误。书中提到了 Fortran 在计算机销售中的重要性，以及作者编写 Fortran 代码的个人经验。 此外，这一集还讲述了汤普森的国际象棋之旅，从迷上国际象棋到开发国际象棋机器。作者分享了他们对在线观看国际象棋比赛以及使用他们创建的 C 程序参加国际象棋比赛的热情。然后，他们描述了制造国际象棋机器的过程以及该机器作为世界和美国冠军的成功。总体而言，本视频集全面概述了 Ken Thompson 对计算机科学领域的贡献，包括他在 UNIX、编程语言和国际象棋方面的工作。对 Brian Kernighan 的采访提供了有关 Thompson 的旅程和突破性技术开发的宝贵见解。</p></details>

- Ian Taylor（Ian Lance Taylor 学士） [Website](https://www.airs.com/ian/), [GitHub](https://github.com/ianlancetaylor), [Quora](https://www.quora.com/profile/Ian-Lance-Taylor)
  + 毕业院校：耶鲁大学
  + [talk/ian2007](https://www.youtube.com/watch?v=gc78olyguqA) <details><summary>GCC：当前主题和未来方向。2007年2月27日。</summary>
    <p><b>总结：</b>在本期 Google 视频技术讲座中，Google GCC 团队成员 Ian Lance Taylor 讨论了 GNU 编译器集合 (GCC) 的当前主题和未来方向。 GCC 是一种广泛使用的 C 和 C++ 编译器，已经积极开发了二十多年。 Taylor 首先解释说，近年来 GCC 的发布流程变得更加严格，从而产生了更加稳定的产品。该项目的活动非常活跃，贡献者众多。他提到编译器正在进行重大重写，以提高准确性和性能，预计 GCC 4.2 将于 4 月或 5 月发布。本集讨论的主要主题之一是改进有关无效别名的警告。泰勒强调理解和解决别名问题的重要性，因为通过不同的指针访问内存可能会产生不可预测的后果。他还提到 GCC 对类型双关发出的警告，这可能会违反严格的别名规则。本集还探讨了语言标准的局限性以及循环执行中带符号溢出的影响。 Taylor 重点介绍了 GCC 4.2 为解决此问题而引入的新选项，包括循环优化和更快的预处理器。这些改进旨在提高编译速度，特别是对于具有许多头文件的项目。还讨论了 GCC 在虚拟机和中间语言开发中的作用。正在进行的与 GCC 相关的项目包括努力使其成为完全自由软件的编译器并生成特定的中间语言。 Taylor 提到了印第安纳大学在 GCC 中实现整个程序优化的工作，它允许跨不同文件内联函数并提高程序效率。本集最后讨论了在 GCC 编译器中使用配置文件反馈、预编译头、自动矢量化和内存优化来优化代码的挑战。 Taylor 提到了 Google 开发人员正在进行的改进以及与 LOV 的合作。总的来说，本集全面概述了 GCC 当前的主题和未来的方向。它强调了解决别名问题的重要性、GCC 4.2 中的改进以及正在进行的与 GCC 在虚拟机和中间语言中的作用相关的项目。还讨论了优化代码的挑战以及 Google 与其他组织之间的协作。</p></details>
  + [talk/ian2018](https://www.youtube.com/watch?v=LqKOY_pH8u0) <details><summary>向 Go 2 转变。2018年 Gopherpalooza，2018年10月24日。</summary>
    <p><b>总结：</b>在题为“Gopherpalooza 2018 - Ian Lance Taylor：过渡到 Go 2”的视频节目中，Google Go 团队成员 Ian Lance Taylor 讨论了将 Go 编程语言过渡到下一个版本 Go 2 的挑战。 Taylor自 2008 年开始接触 Go，在编写自由软件方面拥有丰富的经验。本集首先重点介绍了 Go 从早期到目前稳定状态的历程。 2012年Go 1的发布为用户提供了稳定的平台，带动了Go社区的发展。然而，去年，Go 团队宣布对该语言进行重大更改，包括模块、泛型和错误处理的改进。 Taylor 重点关注 Go 将如何应对这些变化。以 C 为例，强调了管理编程语言版本之间转换的重要性。尽管经历了重大变化，C 仍然通过引入新的关键字和标识符来保持向后兼容性。另一方面，C++经历了更重大的变化和潜在的编译错误。两种语言都提供了在编译期间指定语言版本的选项。文本还以 C++ 和 Java 为例讨论了编程语言中向后兼容性的重要性。它强调了在更改语言的同时保持兼容性的挑战。提到了 Java 弃用功能的过程以及可能删除已弃用功能的情况。还讨论了 Perl 和 Python 编程语言的演变。 Perl 6 面临着漫长的过渡期和来自其他语言的竞争，而 Python 3 已经非常成功，但在从 Python 2 过渡的过程中面临着挑战。 缺乏向后兼容性以及代码重写和库适配的需要减慢了 Python 3 的过渡过程。文中强调了在不破坏现有代码的情况下删除编程语言中的功能的重要性。它建议使用 go fix 等工具自动重命名标识符，并通过简单的解决方法删除破坏代码的功能，以改善用户体验。记录用于在 go 中构建包的 Go 语言版本的想法。 mod 文件进行了讨论。强调了版本兼容性的重要性，建议使用不同语言版本编译Go代码，以确保与旧库的兼容性并利用新的语言功能。本集最后提到不同版本的软件包之间需要兼容，并提出了可能的解决方案。强调了从 Go 1 到 Go 2 的过渡，并提到了旧版本弃用计划的可能性。 Taylor 对他的 Go 体验表示兴奋和感激。</p></details>
  + [talk/ian2019a](https://www.youtube.com/watch?v=WzgLqE-3IhY) <details><summary>Go 的泛型。2019年 GopherCon。2019年8月27日。</summary>
    <p><b>总结：</b>在题为“GopherCon 2019：Ian Lance Taylor - Go 中的泛型”的视频节目中，Ian Lance Taylor 讨论了在 Go 编程语言中实现泛型的优点和要求。他强调了对泛型的需求，并解释说缺乏此功能是 Go 中的一个主要问题。 Taylor 提供了示例来说明 Go 中没有泛型的局限性。他讨论了使用接口作为泛型形式的挑战和局限性，并提出了替代方法。他认为，泛型将消除重复编码和测试的需要，从而实现更高效、更可靠的代码重用。整集都强调了静态类型检查对于高效可靠的代码重用的重要性。 Taylor 解释说，可以通过引入类型参数来添加泛型，并且在大多数情况下，编译器可以推导出类型参数，从而使调用泛型函数与 Go 中的任何其他函数类似。探讨了 Go 编程语言中类型参数和契约的概念。泰勒解释了类型参数如何定义泛型函数中允许的参数类型以及可以对其执行的操作。他还介绍了契约的概念，它描述了通用函数的实现和调用者之间的关系。 Taylor 提供了利用序列契约的函数示例，并解释了如何使用契约来指定通用函数预期使用的类型。他强调在 Go 中实现泛型时需要自然使用和轻松调试，并强调在引入此功能时保持简单性的挑战。本集最后讨论了在 Go 中实现泛型的进展和计划。 泰勒强调反馈的重要性，并旨在设计一个允许用户编写通用代码而不使语言复杂化的系统。他期望根据反馈进行进一步调整，并旨在为 Go 的未来版本提出最终设计。总的来说，视频节目全面概述了在 Go 编程语言中实现泛型的优点和要求。它强调了对此功能的需求，并探讨了与泛型相关的不同方法和概念。本集最后重点讨论了用户反馈的重要性以及设计一个系统的目标，该系统允许在 Go 中轻松高效地编写通用代码。</p></details>
  + [talk/ian2019b](https://changelog.com/gotime/98) Go 的泛型。2019年8月27日。
  + [talk/ian2020](https://www.youtube.com/watch?v=yoZ05GG8aLs) <details><summary>Go 语言与 Ian Lance Taylor。CppCast，2020年8月9日。</summary>
    <p><b>总结：</b>在 CppCast 第 259 集中，Rob 和 Jason 与来自 Google 的 Ian Lance Taylor 一起讨论 Go 编程语言。本集首先讨论 cppcast 不同剧集中涵盖的各种主题，包括飓风及其影响、通过 CMake 使用 PCH 支持的好处、黄金链接器的重要性、使用 Conan 包管理器的优点、Go 的包管理器、以及将内容嵌入 SQL 源二进制文件的工具。主持人随后深入探讨本集的主题，即 Go 编程语言。他们首先强调 Go 和 C++ 之间的差异，强调 Go 的简单性和易学性。他们提到 Go 于 2007 年创建，旨在解决 C++ 缓慢的构建时间和日益增加的复杂性。 Go 内置了对多线程和垃圾收集的支持，使其适合编写网络服务器和各种其他应用程序。讨论继续到 Go 在 Google 的使用，它在 Google 已经很受欢迎并被用于各种项目中。主持人谈论了 Go 的功能，例如 go 例程、通道和 select 语句，这些功能可以创建新的执行线程并在它们之间进行通信。他们还提到，虽然 Go 目前没有泛型，但人们正在努力以符合语言原则的方式添加泛型，目标是在 Go 117 版本中提供泛型。然后主持人解释了编程中类型参数和约束的概念，以及它们如何提高代码可靠性。他们比较了 Go 和 C++ 的设计和功能差异，强调了 Go 的简单性、缺乏专业性和替代失败。 他们提到 Go 是一种具有动态组件的静态类型语言，类似于 C++ 中基于抽象的类。它支持运行时类型反射，并且不具有函数重载或隐式类型转换。本集最后讨论了 Go 编程语言的开发过程和设计理念。主持人提到 Go 鼓励开发人员编写测试，从而产生更好的错误消息。他们还讨论了广泛的 Go 标准库，其中包括对网络服务器、HDP 和 HTML 的支持。主持人强调澄清编程语言实现的重要性，并鼓励听众尝试与 C++ 相比 Go。总体而言，本集全面概述了 Go 编程语言、其功能及其在 Google 的使用。它强调了 Go 的简单性和多线程支持，以及未来可能添加的泛型。主持人还讨论了Go的开发过程和设计理念，强调编写测试和阐明实现的重要性。</p></details>
  + [talk/ian2021a](https://www.youtube.com/watch?v=nr8EpUO9jhw) <details><summary>Using Generics in Go. Dec 6, 2021.</summary>
    <p><b>总结：</b>在题为“Google Open Source Live 上的 Go Day 2021 | 在 Go 中使用泛型”的视频节目中，Ian Lance Taylor 介绍了 Go 编程中的泛型概念，并讨论了如何有效地使用这一新的语言功能。他首先解释了泛型的基础知识，包括类型参数和约束。 Taylor 强调了在定义类型之前编写代码的重要性，并提供了何时使用泛型以及何时不使用泛型的指南。他强调，使用泛型应该是为了代码清晰而不是效率。他还提到，类型参数可用于创建更通用的数据结构并实现更有效的数据存储。演讲者提供了使用泛型创建函数并实现不同类型的通用方法的示例。他解释说，类型参数在实现所有相关类型都相同的方法时特别有用，但在接口类型可以提供所需功能时则不然。 Taylor 在结束本集时提到，Go 1.18 预计将包含对泛型的支持，这将为开发者带来新的可能性。他提到了在 Go 的未来版本中用于对切片进行排序的通用函数的可能性。总的来说，视频节目全面概述了 Go 编程中的泛型。它强调了使用类型参数的好处并提供了其实现的实际示例。演讲者强调了使用泛型来保证代码清晰和避免重复代码的重要性。本集最后提到 Go 1.18 即将支持泛型，这无疑将增强 Go 开发人员的编程体验。 有关 Go 编程的更多信息并了解最新进展，视频建议访问该团队的 golang 网站。组织。此外，该集鼓励听众查看 Go Day 2021 活动页面上提供的所有游戏日会议。</p></details>
  + [talk/ian2021b](https://www.youtube.com/watch?v=Pa_e9EeCdy8) <details><summary>Generics! Dec 17, 2021.</summary>
    <p><b>总结：</b>在题为“泛型！”的 GopherCon 2021 视频节目中，Go 团队成员 Robert Griesemer 和 Ian Lance Taylor 讨论了即将发布的 Go 1.18 及其对泛型函数和类型的支持。它们强调了泛型为 Go 编程语言带来的表达能力以及有效使用它们所带来的责任。 Go 1.18 中的新功能包括类型参数、更强大的接口类型和改进的类型推断。这些功能消除了对类型参数的需要，使得在 Go 中使用泛型进行编程更加高效。此更新还引入了类型约束（定义参数的有效类型）以及定义方法集的接口。 Griesemer 和 Taylor 提供了有关何时何地使用 Go 中通用功能的指南。他们建议从函数而不是类型参数开始，并将类型参数用于对特殊类型进行操作的函数，而不需要对元素类型进行假设。与反射或接口类型相比，它们强调类型参数的灵活性和效率，允许通用数据结构和完全类型检查的代码。演讲者还讨论了理解元类型和使用接口作为通用函数约束的重要性。他们提到了语法糖的引入以及切片类型的类型参数的使用。它们还涉及类型推断及其在从类型参数约束推导类型参数中的作用。 Griesemer 和 Taylor 强调在使用泛型时需要保持 Go 代码的可读性、可维护性和良好的性能。他们建议当多种类型共享具有相同实现的通用方法时使用类型参数，并使用接口类型进行泛型编程和从任何值读取数据。 他们提到，在类型参数没有帮助的情况下可以使用反射。总体而言，即将发布的支持泛型的 Go 1.18 为该语言带来了显着的表达能力。 Griesemer 和 Taylor 就如何有效使用泛型提供了宝贵的指导，强调了根据代码的具体要求选择适当方法的重要性。通过遵循他们的建议，开发人员可以利用泛型的优势，同时保持代码的可读性、可维护性和性能。</p></details>

- Russ Cox（Russell Stensby Cox 博士） [Website](https://swtch.com/~rsc/), [Blog](https://research.swtch.com/), [GitHub](https://github.com/rsc), [Twitter](https://twitter.com/_rsc), [Reddit](https://old.reddit.com/user/rsc)
  + 毕业院校：麻省理工学院
  + [paper/russ2008](https://pdos.csail.mit.edu/~rsc/) 面向扩展的编译器。博士论文。2008年8月20日。
  + [talk/russ2009](https://www.youtube.com/watch?v=wwoWei-GAPo) Go 语言广告。2009年11月10日。
  + [talk/russ2012a](https://www.youtube.com/watch?v=MzYZhh6gpI0) <details><summary>Go 语言之旅。2012年6月24日。</summary>
    <p><b>Summary:</b>在这个题为“Russ Cox 的 Go 编程语言之旅”的视频节目中，Google 软件工程师 Russ Cox 全面概述了 Go 编程语言。他首先解释了创建 Go 及其功能的动机，例如对大型分布式系统和并发的支持。 Cox 深入研究了 Go 中接口的概念，并提供了类型如何实现接口的示例。他特别强调了 Stringer 接口，该接口允许使用字符串方法打印值。他还讨论了在不同数据表示（例如办公室和持续时间）上定义字符串方法的灵活性。然后，视频继续讨论 Go 中的编写器，包括如何使用 fprintf 和 sum32 方法写入数据和检索哈希值。 Cox 引入了多写入器和用于写入十六进制转储的十六进制包的转储器功能。他强调了 Go 中实现接口的灵活性，特别是编写器接口，它允许可互换的实现。他探索了写入器接口在各种场景中的使用，例如写入数据块和哈希函数。视频中还介绍了 Go 编程中 IO 的演变，重点关注接口和反射的重要性。 Cox 解释了接口如何提高 Go 程序员的工作效率，但他警告说，并不是所有事情都可以用它们完成。他引入了反射，允许在运行时使用类型信息和基本操作，但建议谨慎使用它。该视频进一步深入探讨了如何使用 Go 中的 Reflect 包来实现 printf 功能。 Cox 解释了包如何确定值的类型并根据其类型执行不同的操作。 他还提到了 Go 中 printf 动词的不同变体，以及如何调整所使用的工具以其他格式（例如 JSON）进行打印。该视频最后讨论了使用 json 等技术将数据结构转换为编码文本。马歇尔和 XML。马歇尔。 Cox 提供了使用 Go 编程语言从文件中读取和解码 JSON 的示例。他还提到了在 Go 中使用反射将数据转换为 XML 格式，以及 XML 包在解析 XML 编码的聊天消息时的效率。总体而言，本视频节目全面介绍了 Go 编程语言，涵盖其功能、接口、编写器、IO 演变、反射和数据结构转换。</p></details>
  + [talk/russ2012b](https://www.youtube.com/watch?v=dP1xVpMPn8M) <details><summary>Acme 编辑器之旅。2012年9月17日。</summary>
    <p><b>Summary:</b>在这一集中的“Acme 编辑器之旅”中，主持人深入研究了 Acme 的特性和功能，Acme 是一个可定制的文本编辑器，最初是为 Plan 9 开发的，但现在可以在 Unix 系统上使用。他们首先解释 Acme 如何允许使用任何语言的插件进行文本执行和自定义。他们重点介绍了 Acme 提供的窗口布局工具，该工具允许用户自定义屏幕尺寸并自动排列窗口以提高工作效率。然后主持人讨论了 Acme 的各种功能，例如窗口管理、滚动、文本操作、命令执行以及搜索特定单词或文件。他们强调 Acme 的文本操作技巧和快捷方式的效率。主持人还涉及 Acme 中用于导航文件和选择特定行或模式的高级地址语法，强调了其在错误检测和文件搜索方面的便利性。本集进一步探讨了 ACME 词典程序，这是一个 shell 脚本，右键单击时会显示单词定义。他们引入了“win”程序来编辑 shell 输出并与之交互。主持人讨论了 Acme Windows 丰富的寻址和内容合成功能，这些功能可以实现邮件阅读、调试和音乐播放等任务。此外，主持人还深入研究了 Acme 与程序员的各种工具的集成，包括 Acme 文件系统，它允许将文件挂载到内核文件树中。他们讨论了 Plan 9 操作系统中管道规则的使用来解释文本并生成操作，例如打开文件或启动 Web 浏览器。 这一集还涉及到使用 Acme 进行流式传输、测试驱动开发，以及创建一个名为“watch”的新程序来监视目录更改。在整个节目中，主持人分享了他们使用 Acme 的经验，包括遇到编译器错误和修复与 JSON 解码相关的错误。他们最后强调 Acme 是一个高效的文本驱动编程系统。欲了解更多信息，听众可访问 http://research.swtch.com/acme</p></details>
  + [talk/russ2014](https://www.youtube.com/watch?v=QIE5nV5fDwA) <details><summary>从 C 到 Go。2014年 GopherCon。2014年5月18日。</summary>
    <p><b>Summary:</b>在题为“GopherCon 2014 Go from C to Go by Russ Cox”的视频节目中，Russ Cox 讨论了将 C 代码转换为 Go 代码的挑战，并建议使用工具自动化该过程。目前用 C 编写的 Go 编译器有局限性，用 Go 重写会更高效。 Cox 提供了 C 编程语言及其发展的历史概述，强调了 C 和 Go 之间的差异，例如控制流和程序模型。目标是自动化转换过程，同时保持原始代码的结构和清晰度。 Cox 解释了 Go 编译器中联合的概念，以及将结构转换为联合如何节省内存空间。但是，如果使用多个字段，也可能导致不正确的程序行为。在 Go 代码中保留语义和注释非常重要，Cox 解释了转换器如何处理此问题。他还讨论了 go-to 语句在 C 编程和汇编编程中的使用，以及将它们翻译成 Go 的挑战。 Cox 探索了分析整个编译器源代码以识别连接值簇的过程以及代码分析中 return 语句的使用。他提供了集群及其类型的示例，强调了程序理解工具和代码分析的潜力。播客节目最后更新了将编译器片段转换为 Go 的进度，并鼓励用户在发布前尝试 Go 1.3 beta 来识别和修复错误。 Cox 提到了将代码从 C 转换为 Go 的挑战和机遇以及使用分析器的好处。总的来说，这一集提供了有关将 C 代码转换为 Go 代码的挑战以及 Go 团队自动化该过程所采取的方法的宝贵见解。</p></details>
  + [talk/russ2015](https://www.youtube.com/watch?v=XvZOdpd_9tc) <details><summary>Go、开源、社区。2015年 GopherCon。2015年7月28日。</summary>
    <p><b>Summary:</b>在 GopherCon 2015 主题演讲中，Russ Cox 讨论了 Go 开源项目的目标和挑战。他强调了可扩展并发和协作软件开发的重要性。 Cox 提到，Go 由于与 Google 内部代码库相似，因此在云软件和开源项目中取得了成功。该演讲重点介绍了 Go 的特性，这些特性使可扩展的并发性和软件开发变得更加容易。 Go 专注于为开发人员提供足够的功能来构建自己的解决方案以及与他人的互操作性。本文讨论了通道和 goroutine 在解决并发软件中常见问题时的用处，以及 Go 中静态类型和接口的好处。 Cox 还提到了 Go 测试包以及重构和程序分析在支持自动更新方面的重要性。他进一步讨论了 Go 编程语言中共享约定的建立以及开源协作的好处。 Go 编程语言的成功归功于其开源特性，它允许多样化的用户群和资源访问。 Google 的开放开发流程以及接受任何人贡献的源代码有助于 Go 社区的发展。 Google Go 团队的角色已经从开发转变为指导，专注于协调变更并确保一致性。该团队现在专注于代码审查和错误处理，而设计和开发则由更广泛的 Go 社区负责。 Cox 还提到由 IhramHarvardYano 领导的一组贡献者成功地将 Go 移植到 ARM 64 架构。这标志着谷歌以外的架构师首次实现这一目标。 本文讨论了 Google 的供应商方法以及 Google 以外的用户开发的各种工具之间的兼容性问题。发起了公开讨论，以建立导入路径重写和文件格式描述的通用方法。强调在 Go 社区中制定行为准则对于促进包容性和尊重的重要性。有效的沟通和温馨的环境被认为对于社区的发展至关重要。总体而言，演讲提供了 Go 编程语言的最新动态，并邀请观众参与和反馈。</p></details>
  + [talk/russ2016](https://www.youtube.com/watch?v=h6Cw9iCDVcU) <details><summary>使用 Go 重构代码库。2016年12月5日。</summary>
    <p><b>Summary:</b>在 Russ Cox 题为“GothamGo 2016 代码库重构（在 Go 的帮助下）”的视频中，讨论了在 Go 中使用大型代码库的挑战以及可扩展性的重要性。 Cox从早期就参与了Go编程语言的开发，他分享了他对Go如何更好地协助代码包结构重构的见解。这一集首先强调了处理大型代码库（例如 Google 的单一存储库）时所面临的挑战，并强调了高效导入和最小化不必要依赖项的必要性。 Cox 解释了将代码拆分为单独包的原因，其中包括提高可管理性和减少依赖性。 Cox 随后讨论了代码库重构的过程，建议将其分为三个阶段：进行初步更改、更新代码以使用新 API 以及删除旧 API。这种渐进的方法可以更轻松地审查和提交较小的提交，特别是在处理分布在多个存储库中的代码时。该播客还深入探讨了在 Go 编程中实现可互换性的挑战。虽然函数和类型可以定义为可互换的，但将类型从一个包移动到另一个包会带来限制。 Cox 提到了 2011 年实施的解决方案，但表示它可能并不理想。他还强调了 Kubernetes 项目在代码库中移动类型时面临的困难。 Cox 提议添加一种机制来为类型创建可互换的名称，并强调 Go 需要支持逐步代码修复以在包之间移动类型。 他对有关此事的意见表示感谢，并提到正在重新评估类型别名的包含，以确定适当的行动方案。总的来说，该播客提供了有关在 Go 中使用大型代码库的挑战的宝贵见解，并提供了改进代码库重构和实现可互换性的建议。</p></details>
  + [talk/russ2017](https://www.youtube.com/watch?v=0Zbh_vmAKvk) <details><summary>Go 的特性。2017年 GopherCon. 2017年7月24日。</summary>
    <p><b>Summary:</b>在题为“GopherCon 2017：Russ Cox - Go 的未来”的视频中，Russ Cox 讨论了 Go 编程语言的历史和发展。他强调了关键人物在构建编译器和标准库方面的合作，最终导致了 Go 1 的发布，这标志着生产环境中向稳定性和使用的转变。 Cox 表达了他希望与 Go 社区合作来规划和实现 Go 的未来，特别是在可扩展性方面。讨论了从 Go One 过渡到 Go Two 的挑战，强调兼容性和仔细规划的必要性。 Cox解释说，Go的开发过程已经从非正式演变为正式，包括问题识别、提出解决方案、实施和评估。他强调描述问题的重要性以获得解决问题的支持的重要性，因为不考虑问题的重要性可能会导致即使是简单的程序也会失败。 Cox 还讨论了经验报告对于理解和解决 Go 编程语言问题的重要性。他认为，Go 中的问题最好通过库和工具更改而不是语言更改来解决。作为 Go one 版本的一部分，逐步发布 Go 的向后兼容部分的计划可确保及时修复和改进错误，避免分散开发工作，并简化迁移。 Cox 推测，微小的变化可能会在大约一年内开始出现，然后是包管理支持，并最终过渡到 Go 2.0。总体而言，播客节目提供了有关 Go 编程语言的历史、发展和未来计划的见解。 Cox 的讨论强调了协作、解决问题和社区参与在塑造 Go 未来方面的重要性。</p></details>
  + [talk/russ2018a](https://changelog.com/gotime/77) Go 的依赖和特性。2018年4月19日。
  + [talk/russ2018b](https://changelog.com/gotime/bonus-77) Go 和 WebAssembly (Wasm). 2018年4月19日。
  + [talk/russ2018c](https://www.youtube.com/watch?v=F8nrpe0XWRg) <details><summary>开幕演讲：Go 和 版本。2018年 GopherConSG。2018年5月5日。</summary>
    <p><b>Summary:</b>在 GopherConSG 2018 的开幕主题演讲中，Russ Cox 讨论了 Go 编程语言中包版本控制的必要性。他强调了开发人员由于版本不兼容和构建损坏而面临的挑战。目前，Go 缺乏对包版本的感知，这使得创建版本感知工具变得困难。 Cox 建议通过新的导入路径语法和版本选择算法将包版本直接添加到 Go。他强调了软件工程中的兼容性、可重复性和协作原则。兼容性可确保程序中名称的含义随着时间的推移保持一致，从而简化开发和维护。然而，语义版本控制会导致软件版本之间的不兼容，被视为一个缺点。为了解决兼容性问题，Cox 建议使用语义导入版本控制，其中不同的主要版本使用不同的导入路径。 Go 中的导入路径通过消除歧义来简化软件工程。升级到模块的不同版本可能需要更改导入路径，但全局搜索、替换和修复等工具可以使此过程变得更容易。导入路径允许逐步更新并清楚地识别转换后的代码，而语义版本控制有助于避免冲突和钻石依赖性问题。本书还探讨了软件开发中导入版本控制和可重复性的概念。它讨论了不同版本控制系统面临的挑战以及在软件工程中考虑这些原则的重要性。可重复性对于依赖管理系统至关重要，以确保部署期间的错误修复和安全更新。强调库构建中最新依赖项和可重复性之间的平衡。 强调合作在非政府组织开源生态系统中至关重要。作者之间的合作对于解决兼容性问题以及发布修复和更新是必要的。如果没有合作，生态系统就会面临失败的风险。总之，Cox 强调了版本控制在 Go 工具链和生态系统中的重要性。他鼓励开发者尝试 Go 1.11 中的新版本支持并提供反馈。通过实施包版本控制，Go 可以解决兼容性问题，确保构建的可重复性，并培育健康、繁荣的开源生态系统。</p></details>
  + [talk/russ2018d](https://www.youtube.com/watch?v=6wIP3rO6On8) <details><summary>Go 2 草稿宣布。2018年8月28日。</summary>
    <p><b>Summary:</b>在本期视频中，Go 团队提供了有关他们在解决 Go 用户调查中的前三个请求方面所取得的进展的最新信息。这些请求包括更好的包管理、错误处理和泛型。该团队引入了 Go 模块，这些模块已在 Go 1.11 中引入，作为改进包管理和实现灵活代码组织的解决方案。他们承认生态系统需要时间来适应模块，但他们相信从长远来看这将使社区受益。该团队还讨论了进一步讨论错误处理的必要性，并提出了改进它的解决方案。他们建议添加“check”表达式和“handle”语句来增强 Go 中的错误处理。此外，该团队还探索了使用泛型来实现更灵活和可重用代码的概念。他们讨论了使通道元素类型成为可以在代码中变化的参数的想法，以及指定哪些类型可以代替参数所带来的挑战。该团队还引入了契约的概念，它定义了类型必须支持的操作。他们提供了一个名为“Equal”的合约示例，用于比较 T 类型的值是否相等。该团队鼓励 Go 用户提供有关 Go 2 持续开发的反馈，并邀请他们帮助改进错误处理、错误值和泛型的设计草案。他们提供了有关如何执行此操作的更多信息的链接。</p></details>
  + [talk/russ2019](https://www.youtube.com/watch?v=kNHo788oO5Y) <details><summary>Go 2 路径图。2019年 GopherCon。2019年8月27日。</summary>
    <p><b>Summary:</b>在 GopherCon 2019 视频“On the Path to Go 2”中，Russ Cox 讨论了 Go 编程的演变以及该语言的未来方向。本集首先强调简化 Go 程序编写过程的重要性。考克斯解释说，这可以通过重塑、重新定义、删除和限制语言的某些方面来实现。本集中强调的一个改进领域是错误处理。 Cox 提供了 Go 错误处理演变的历史概述，强调了 Go 错误的强大功能和灵活性。他介绍了使用 unwrap 方法通过删除不必要的上下文来简化错误处理的约定。此外，他还提到了错误等辅助函数的引入。是和错误。至于处理特定的错误类型。本集还涉及 Go 中错误语法和泛型的设计。 Cox 解释了错误处理中面临的最初设计挑战以及关注该语言其他方面的决定。不过，他提到了基于去年提出的合同想法的新设计。本集中讨论的另一个主题是 Vigo 设计中从 Go Path 到 Go Modules 的过渡。这种转变结束了 Go Path 的全局命名空间，并引入了可重复构建的挑战。 Cox 提到了使用替换包“golang”的重要性。 org/X/tools/go/packages' 用于开发工具中更快的功能。本集最后讨论了 Go 中包管理的演变以及供应商目录的引入。 Cox 强调了依赖管理工具的目标和问题，从而促成了 Vigo 的开发。 他提到，Google 的 Go 团队已经推出了所有开源 Go 包的公共镜像，Go 模块现在已经可以为大多数用户服务。总的来说，这一集强调了在简化 Go 开发过程中实验和学习的价值。 Cox对Go社区表示感谢，并提到Go项目正在将重点转向提供完整的IDE服务支持，开发了统一开发助手的工具Go Please。</p></details>
  + [talk/russ2020a](https://go.dev/s/go-build-video) `go:build` 设计草稿。2020年6月30日。
  + [talk/russ2020b](https://go.dev/s/draft-iofs-video) `os/fs` 包设计草稿。2020年7月21日。
  + [talk/russ2020c](https://go.dev/s/draft-embed-video) `//go:embed` 包设计草稿。2020年7月21日。
  + [talk/russ2021](https://www.twitch.tv/videos/1203523364) #PLTalk: Russ Cox 的 12 年 Go 经历。 2021年11月12日。
  + [talk/russ2022](https://youtube.com/watch?v=v24wrd3RwGo) <details><summary>Compatibility: How Go Programs Keep Working. GopherCon 2022. Oct 28, 2022.</summary>
    <p><b>Summary:</b>在题为“GopherCon 2022：Russ Cox - 兼容性：Go 程序如何保持工作”的视频中，Russ Cox 讨论了 Go 编程中兼容性的重要性以及 Go 团队为确保新版本的稳定性和可预测性而采用的策略。 Cox 首先解释了 Go1 兼容性承诺，该承诺保证可以在不破坏现有代码的情况下添加新的 API。他强调了维护 API 兼容性的重要性，并讨论了用于检查兼容性问题的工具和测试方法。本集重点介绍了 Go 1.1 版本准备过程中遇到的两个微妙问题，揭示了维护兼容性的挑战，包括输出更改、输入更改和协议更改。 Cox 还深入研究了 Go 1.6 中的更改和兼容性，包括选择退出更改的能力以及取消对 sha-1 证书的支持。讨论进一步探讨了向后、向前和语言兼容性，以及与输出和输入变化相关的挑战。提供示例来说明输出更改不兼容性以及输入更改引起的问题。 Cox 强调编写可接受任何有效行为的代码和测试的重要性。他还使用由于数据格式和 HTTP 版本之间的通信问题而导致的代码破坏示例，讨论了输入更改不兼容性和协议更改。该集还涉及 Goatee bug 设置和 Go 编程中的兼容性，强调了破坏现有程序的兼容更改将持续至少两年的保证。 Go 命令正在考虑改进以更有效地处理版本不匹配。 最后，本集讨论了如何利用 Go 模块来删除或修复 Go 语言中的有问题的功能。识别出代码中的错误，并建议潜在的修复方案。总的来说，这一集强调了在 Go 1.x 开发中优先考虑兼容性以及为开发人员保持稳定性和可预测性的重要性。</p></details>
  
[Back To Top](#top)

### 编译运行时团队

Dmitry 来自谷歌动态测试工具团队而不是 Go 团队。他编写了可伸缩的 goroutine 调度器，很多的性能提升，早期的同步，race 检测，Go 运行时阻塞分析器。Austin 在攻读博士期间是谷歌的实习生，在 Go 项目早期工作。后来，在他结束学生生涯后加入了 Go 团队，和 Rick 一起从事 Go 并发 GC 工作。他也在做抢占式调度器和链接器的工作。他现在是 Go 语言编译运行时团队的领导人。Keith 和 David 一起专注于 Go 编译器后端，尤其是当前的 SSA 后端。Michael 是 Go 团队的新成员，他的主要工作是运行时内存系统，例如内存分配器的重构和运行时指标。

- Dmitry Vyukov（Дмитрий Вьюков 理学硕士）[Website](http://www.1024cores.net/), [GitHub](https://github.com/dvyukov), [Twitter](https://twitter.com/dvyukov)
  + 毕业院校：莫斯科国立鲍曼技术大学
  + [talk/dmitry2014](https://www.youtube.com/watch?v=QEhpLb0UCfE) 用 Go 编写一个函数式的可靠快速的 Web 应用。2014年9月25日。
  + [talk/dmitry2015a](https://www.youtube.com/watch?v=Ef7TtSZlmlk) <details><summary>和 Dmitry Vyukov 的谈论：Go 语言和信息安全。 2015年7月3日。</summary>
    <p><b>Summary:</b>在这个题为“与 Dmitry Vyukov 讨论 go-fuzz、golang 和 IT 安全”的视频中，Google 软件工程师 Dmitry Vyukov 讨论了他的工具 go-fuzz，该工具用于发现软件缺陷。对话发生在德米特里和一群 gopher 之间，其中包括尼古拉斯·格里利、弗雷德·梅内斯和亚历克斯·普鲁加鲁。在一开始时，大家对 Dmitry 接受邀请谈论 go-fuzz 表示感谢。他们提到，他们的对话视频将在即将举行的一场以 golang 和 IT 安全为主题的聚会活动中展示。然后 Dmitry 继续解释 go-fuzz 的概念及其在信息安全自动化测试中的重要性。他还谈论了他在 C、C++ 和 Go 语言动态测试工具方面的工作。该小组表示有兴趣了解更多有关 go-fuzz 和相关主题的信息。然后话题转向 Century 和 Trust 这两家公司的活动，以及即将举行的信息安全聚会的计划。 Dmitry 介绍了 GoFast，这是一个为 Go 编程语言创建的归档系统，并暗示要展示一个小型演示文稿。该小组讨论了为随机测试生成有意义的输入所面临的挑战，这是一种经济高效且公正的检查软件崩溃和问题的方法。 Dmitry 解释了覆盖技术，该技术使用遗传算法通过生成不同的输入来识别错误和极端情况。他还提到了声纳技术，该技术涉及向程序添加仪器以识别和替换错误。然后，对话深入探讨了 Hinkle Versa Fire 和 Summer 技术在生成和测试 XML 解析输入方面的使用。 Dmitry 解释了 Go Fast 编程语言中的 XML 解析过程，并描述了 Go Fast 的整体结构。本集最后讨论了 Go 编程语言中各种包的问题以及彻底测试的重要性。 Dmitry 强调使用这些包时需要谨慎，并建议使用覆盖引导系统来检测 Go 程序中的错误。总的来说，这一集为软件测试、信息安全以及使用模糊测试作为发现软件缺陷的工具提供了宝贵的见解。</p></details>
  + [talk/dmitry2015b](https://www.youtube.com/watch?v=a9xrxRsIbSU) <details><summary>Go 动态工具。2015年 GopherCon。2015年7月28日。</summary>
    <p><b>Summary:</b>在题为“GopherCon 2015：Dmitry Vyukov - Go 动态工具”的视频中，Dmitry Vyukov 讨论了动态工具在 Go 编程中的重要性。他强调，这些工具可以通过少量的时间投入提供巨大的价值，但往往被开发人员低估。 Vyukov 介绍了 Go 的三种动态工具：数据竞争检测器、模糊测试系统和执行跟踪器。数据竞争检测器对于识别和修复并发代码中的数据竞争至关重要，这可能会损害程序的正确性、稳定性和安全性。 Go 提供了一个内置的数据竞争检测器，可以通过编译器检测和运行时模块轻松识别和解决数据竞争。模糊测试系统是一种错误查找工具，使用并发测试、随机测试和覆盖引导模糊测试等技术。它通过生成随机数据和改变输入以触发之前未执行的代码行的执行来帮助识别潜在的错误。 Vyukov 解释了如何在 C 和 C++ 程序的安全测试以及使用 Versa Fire 协议的图像验证和 XML 输入中使用增量输入突变。执行跟踪器可以深入了解 Go 程序中的性能和延迟问题。它可以帮助开发人员理解和优化代码的执行流程。维尤科夫还分享了他大规模系统应用这些动态工具的经验。他强调了 Go 包中测试和错误发现的重要性，并提供了 Go 基金包中发现的错误示例。他建议使用“go fast”工具来测试并彻底测试软件包的可靠性。 总体而言，本播客集强调了 Go 编程中动态工具的价值，并鼓励开发人员利用它们来查找错误、性能优化和整体程序可靠性。</p></details>
  + [talk/dmitry2016](https://www.youtube.com/watch?v=9cpN2r22sLE) Dmitry Vyukov 的采访。2016年6月1日。
  + [talk/dmitry2017](https://www.youtube.com/watch?v=FD30Qzd6ylk) 模糊测试：新单元测试。2017年俄罗斯 C++。2017年3月10日。
  + [talk/dmitry2018a](https://www.youtube.com/watch?v=EJVp13f_aIs) 模糊测试：新单元测试。俄罗斯 GopherCon。2018年4月2日。
  + [talk/dmitry2018b](https://www.youtube.com/watch?v=qrBVXxZDVQY) <details><summary>Syzbot 和数千个内核 Bug 的故事。2018年9月1日。</summary>
    <p><b>Summary:</b>在题为“Syzbot 和千个内核错误的故事”的视频中，来自 Google 的 Dmitry Vyukov 讨论了 Linux 内核错误的现状及其安全影响。过去三年来，Vyukov 和他的团队一直在测试内核，遇到了大量对系统安全构成威胁的 bug。 Vyukov 强调，虽然强化、缓解措施和容器很重要，但它们无法完全保护具有数千个错误的系统。因此，解决这些缺陷对于保证Linux内核的稳定性和安全性至关重要。为了帮助识别和修复这些错误，Vyukov 和他的团队开发了一套错误查找工具。这些工具包括 syzbot、syzkaller、KASAN、KMSAN 和 KTSAN。这些工具有助于检测和解决内核中的漏洞，提高其整体安全性。然而，维尤科夫承认仍然存在需要解决的挑战。主要挑战之一是需要处理的错误数量巨大。此外，管理和维护稳定版本也存在困难，以及现有错误跟踪系统的限制。维尤科夫呼吁社区帮助改善这种情况。他强调了更好的测试流程以及结合各种类型的测试和错误跟踪工具的重要性。沟通和报告在软件开发中也至关重要，维尤科夫建议使用特定的电子邮件地址来提交提案。总之，Vyukov 的演讲揭示了内核错误的重大问题及其对系统安全的影响。他强调需要不断努力解决这些错误并提高 Linux 内核的稳定性和安全性。 随着错误查找工具的开发和社区支持，有可能在解决这些漏洞和确保内核的可靠性方面取得重大进展。</p></details>
  + [talk/dmitry2019](https://www.youtube.com/watch?v=-K11rY57K7k) <details><summary>Go 调度器：以轻量级并发实现编程语言。2019年10月14日。</summary>
    <p><b>Summary:</b>在题为“Dmitry Vyukov — Go 调度程序：用轻量级并发实现语言”的视频中，Dmitry Vyukov 深入研究了 Go 调度程序的内部工作原理，并阐明了它如何实现 goroutine 和 channel 看似神奇的功能。 Vyukov 首先概述了调度程序的主要组件及其整体操作。他解释说，Goroutine（轻量级线程）和 Channel（FIFO 队列）是 Go 中并发的构建块。然而，他强调，它们的实施并不涉及任何魔法。然后讨论深入到调度程序的具体方面，例如处理阻塞系统调用和解决 goroutine 中的死锁问题。 Vyukov 提出了提高并行性和可扩展性的解决方案，包括进入内核并唤醒另一个线程来解决死锁。可扩展性是本集中解决的另一个挑战，建议允许多个 goroutine 同时使用相同的调度程序状态。 Vyukov 还探讨了硬件和软件层面的争用和上下文丢失的挑战，提出了减少争用和频繁锁定等解决方案。强调了 goroutine 调度中公平性的重要性，因为缺乏公平性可能会产生负面后果。Vyukov 解释了如何通过抢占、时间片和运行队列来实现公平性。他还讨论了 goroutine 中的饥饿问题，并建议使用时间片继承来解决该问题。本集涉及各种优化技术，包括使用处理器来改进工作窃取、负载平衡和内存分配。 Vyukov 强调了公平与性能之间的权衡以及高效资源利用的必要性。解释了栈和内存分配的实现，重点是防止栈溢出和管理大量的goroutine。 Vyukov 讨论了 32 位系统面临的挑战并提出了诸如拆分堆栈之类的解决方案。本集还介绍了拆分堆栈和全局堆栈实现之间的性能差异，后者提供了更好的性能和稳定性。总之，Vyukov 强调了 Go 语言中调度器设计、堆栈管理和抢占的重要性。他讨论了优化代码执行和提高处理器调度效率和可扩展性的各种方法。这一集还讨论了抢占对于垃圾收集和系统性能的重要性。</p></details>
  + [talk/dmitry2020](https://www.youtube.com/watch?v=YwX4UyXnhz0) <details><summary>syzkaller：连续覆盖引导内核模糊器。2020年 BlueHat IL。2020年2月13日。</summary>
    <p><b>Summary:</b>在题为“BlueHat IL 2020 - Dmitry Vyukov - syzkaller：连续覆盖引导的内核模糊测试中的冒险”的视频中，Dmitry Vyukov 讨论了 syzkaller 项目，这是一个开源、覆盖引导、结构感知的内核模糊器。他首先解释了该项目背后的历史和动机，强调了内核模糊测试与用户空间模糊测试相比的挑战，例如覆盖范围薄弱、测试隔离和巨大的输入空间。然后，维尤科夫深入研究了使 syzkaller 项目能够克服这些挑战的主要设计决策。他讨论了接口描述语言的使用、syzkaller 程序符号和解释以及代码覆盖支持的实现。事实证明，这些设计决策可以有效地发现各种操作系统中的数千个错误。该播客节目还谈到了对动态工具进行良好测试的重要性，并介绍了无害模糊测试的概念，作为检测内核中更多错误的技术。传统的模糊测试技术是有限的，Vyukov 引入了代码覆盖率引导的模糊测试作为一种更有效的方法。此外，本集探讨了编程中系统调用和阻塞的概念，强调了系统调用的优先级和分派以处理阻塞情况的重要性。讨论还包括对管理系统调用和处理阻塞场景的见解。 Vyukov 还讨论了 Sis Bot 的实施，这是一个在 syzkaller 项目之上实现自动化并提供更高级别自动化的系统。 Sis Bot 提供持续的内核和调用者构建，提供更新和自动化以提高效率。 该系统已报告上游 Linux 内核中约 2, 900 个错误，其中 2, 000 个已修复，800 个未解决。总体而言，本视频全面概述了 syzkaller 项目及其对持续覆盖引导的内核模糊测试的影响。 Vyukov 的见解和经验揭示了内核模糊测试的挑战和成功，并强调了动态工具和测试在开发安全可靠的操作系统中的重要性。</p></details>

- Austin Clements（Austin T. Clements 博士）[GitHub](https://github.com/aclements), [Scholar](https://scholar.google.com/citations?user=MKDtxN4AAAAJ)
  + 毕业院校：麻省理工学院
  + [paper/autin2014](https://pdos.csail.mit.edu/papers/aclements-phd.pdf) 可伸缩交换规则：为多核处理器设计可伸缩软件。博士论文。2014年5月21日
  + [talk/austin2020](https://www.gophercon.com/agenda/session/233441) 原谅中断：Go 1.14 中的循环抢占。2020年11月12日。

- Richard Hudson（Richard L. Hudson 理学硕士）[GitHub](https://github.com/RLH)（退休）
  + 毕业院校：马萨诸塞大学阿默斯特分校
  + [paper/rick](https://dl.acm.org/profile/81100566849/publications?Role=author) List 研究
  + [talk/rick2015a](https://www.youtube.com/watch?v=aiv1JOfMjm0) Go 垃圾回收：解决延迟问题。2015年 GopherCon，2015年7月8日。
  + [talk/rick2015b](https://www.infoq.com/interviews/hudson-go-gc/) Go 垃圾回收：Rick Hudson。2015年12月21日。

- Keith Randall（Keith H. Randall 博士）[GitHub](https://github.com/randall77)
  + 毕业院校：麻省理工学院
  + [paper/1998keith](http://supertech.csail.mit.edu/papers/PPoPP95.pdf) Cilk 语言：高校多线生程计算。博士论文。 1998年5月21日。
  + [talk/keith2016](https://www.youtube.com/watch?v=Tl7mi9QmLns) Map 内部实现。2016年 GopherCon，2016年7月12日。
  + [talk/keith2017](https://www.youtube.com/watch?v=uTMvKVma5ms) 用 SSA 生成更好的机器码。2017年 GopherCon，2017年7月24日。

- David Chase（David Chase 博士）[Website](http://chasewoerner.org/resume.html), [Block](https://dr2chase.wordpress.com/), [GitHub](https://github.com/dr2chase), [Twitter](https://twitter.com/dr2chase), [Scholar](https://dblp.org/pid/51/3488.html)
  + 毕业院校：莱斯大学
  + [paper/1987david](http://www.chasewoerner.org/dissertation.pdf) 垃圾回收和其他优化。博士论文。 1987年8月。
  + [talk/david2017](https://changelog.com/gotime/52) Go 编译器详述。2017年7月20日。

- Dan Scales.
  + [talk/dan2020](https://www.gophercon.com/agenda/session/233397) 实现更快的 defer。2020年11月11日。

- Michael Knyszek. [Website](https://www.ocf.berkeley.edu/~mknyszek/), [GitHub](https://github.com/mknyszek)
  + [talk/michael2020](https://www.gophercon.com/agenda/session/233086) 提升 Go 内存管理器的 RAM 和 CPU 效率。2020年11月11日。

- Than McIntosh. [GitHub](https://github.com/thanm)

- Cherry Zhang. [GitHub](https://github.com/cherrymui)

### 仓库、工具、安全、社区

- Andrew Gerrand [GitHub](https://github.com/adg), [Twitter](https://twitter.com/enneff)
- Brad Fitzpatrick [Website](https://bradfitz.com/), [GitHub](https://github.com/bradfitz), [Twitter](https://twitter.com/bradfitz)
  + [talk/brad2010](https://www.youtube.com/watch?v=c4znvD-7VDA) 编写 zippy 安卓应用。2010年谷歌网络开发者大会。2010年5月27日。
  + [talk/brad2011](https://www.youtube.com/watch?v=OExxMUVVjRM) Palestra Brad FitzPatrick：Perl 工厂。第1部分，2011年5月12日。
  + [talk/brad2012](https://www.youtube.com/watch?v=zHXoDB07Iwg) LiveJournal 幕后：缩放的故事时间。2012年5月21日。
  + [talk/brad2013a](https://www.youtube.com/watch?v=sYukPc0y_Ro) 令我高兴的软件。2013年 dotScale。2013年7月30日。
  + [talk/brad2013b](https://www.youtube.com/watch?v=kJ68OWnlycQ) LiveJournal 莫斯科办公室。Brad Fitzpatrick。2013年12月15日。
  + [talk/brad2014a](https://www.youtube.com/watch?v=Ds0KXj8ohR8) Camlistore。Go 集会。2014年1月
  + [talk/brad2014b](https://www.youtube.com/watch?v=D6okO8Qzusk) Camlistore 和标准仓库。2014年 GopherCon。2014年5月18日。
  + [talk/brad2014c](https://www.youtube.com/watch?v=4KFTacxqkcQ) Gopher 的状态。2014年 dotGo，2014年10月10日。
  + [talk/brad2014d](https://www.youtube.com/watch?v=VLciNxKAKyc) 采访。2014年 dotGo，2014年11月6日。
  + [talk/brad2015a](https://www.youtube.com/watch?v=yG-UaBJXZ80) Andrew 和 Brad 的工作：一个 HTTP/2 客户端。2015年2月25日。
  + [talk/brad2015b](https://www.youtube.com/watch?v=gukAZO1fqZQ) HTTP/2 和 Go。2015年伦敦 Go 集会。2015年3月4日。
  + [talk/brad2015c](https://www.youtube.com/watch?v=gAfoLwog_MA) Go 里的 HTTP/2。2015年欧洲开源开发者会议 Go 开发室。2015年3月4日。
  + [talk/brad2015d](https://www.youtube.com/watch?v=rHBbqjWCGq8) Gopher 的状态。慕尼黑 Gopher。2015年4月18日。
  + [talk/brad2015e](https://www.youtube.com/watch?v=stram5J144s) Go 语言。2015年波兰 devoxx。2015年6月。
  + [talk/brad2015f](https://www.youtube.com/watch?v=1rZ-JorHJEY) Andrew 和 Brad 的工作：tiop.go.dev。2015年1月8日。
  + [talk/brad2015g](https://www.youtube.com/watch?v=mj-1wscEQO8) 快速采访：Go 的 HTTP/2。2015年 GopherCon。2015年8月19日。
  + [talk/brad2015h](https://www.youtube.com/watch?v=xxDZuPEgbBU) Go 的分析及优化。2015年8月27日。
  + [talk/brad2016a](https://www.youtube.com/watch?v=4Dr8FXs9aJM) Go 1.6 介绍：逐渐接近单调。2016年印度 GopherCon。2016年3月29日。
  + [talk/brad2016b](https://www.youtube.com/watch?v=4yFb-b5GYWc) 快速谈话：我的视频和安全系统。2016年 GopherCon。2016年7月。
  + [talk/brad2016c](https://www.youtube.com/watch?v=8cQcPnzfkLk) Go 1.7。西雅图 Go 集会。2016年8月25日。
  + [talk/brad2016d](https://www.youtube.com/watch?v=18kmlJvR6Bk) Go 开源项目的内部结构。2016年 GothamGo。2016年12月15日。
  + [talk/brad2017](https://www.youtube.com/watch?v=4fWqcOubYQ0) 我的前半生在开源项目。2017年3月19日。
  + [talk/brad2018a](https://www.youtube.com/watch?v=ZCB-g2B4Y5A) Go：回顾和展望。2018年4月2日。
  + [talk/brad2018b](https://www.youtube.com/watch?v=rWJHbh6qO_Y) Go 1.11 和未来。2018年8月26日。
  + [talk/brad2018c](https://www.youtube.com/watch?v=69Zy77O-BUM) 快速谈话：核选项，`go test -run=InQemu`。2018年 GopherCon，2018年9月11日。
  + [talk/brad2019](https://www.youtube.com/watch?v=BRSam0xQJKY) Brad Fitzpatrick 更喜欢 Go，而非 C, C++, Rust, Perl, Python, Ruby, JavaScript 和 Java。2019年11月28日。

- Bryan C. Mills. [GitHub](https://github.com/bcmills)
  + [talk/bryan2017](https://www.youtube.com/watch?v=C1EtfDnsdDs) 快速谈话：sync.Map 的概述。2017年 GopherCon，2017年7月24日。
  + [talk/bryan2018](https://www.youtube.com/watch?v=5zXAHh5tJqQ) 重新思考经典的并发模式。2018年 GopherCon，2018年9月14日。

- Dmitri Shuralyov. (Dmitri Shuralyov, M. Sc.) [Website](https://dmitri.shuralyov.com/), [GitHub](https://github.com/dmitshur), [YouTube](https://www.youtube.com/c/DmitriShuralyov)
  + [talk/dmitri2016](https://www.youtube.com/watch?v=9XTl1d4nwdY) Go in the browser. dotGo. 2016年10月10日。

- Steve Francia. [Website](https://spf13.com/), [GitHub](https://github.com/spf13), [Twitter](https://twitter.com/spf13).
  + [talk/steve2019a](https://spf13.com/presentation/what-should-a-modern-practical-programming-language-look-like/) 现代实用编程语言应该是什么样子。Langding Festival，2019年4月4日。
  + [talk/steve2019b](https://spf13.com/presentation/the-legacy-of-go/) Go 的遗产。Go Lab，2019年10月22日。

- Jonathan Amsterdam.
  + [talk/jonathan2020](https://www.gophercon.com/agenda/session/233432) Errors 方面。2020年11月13日。

- Daniel Martí. [Website](https://mvdan.cc/), [GitHub](https://github.com/mvdan), [Twitter](https://twitter.com/mvdan_)

- Nigel Tao. [GitHub](https://github.com/nigeltao), Twitter

- Michael Matloob. [GitHub](https://github.com/matloob), [Twitter](https://twitter.com/matloob)

- Jay Conrod. [Website](https://jayconrod.com/), [Twitter](https://twitter.com/jayconrod)

- Dave Cheney. [Website](https://dave.cheney.net/), [GitHub](https://github.com/davecheney), [Twitter](https://twitter.com/davecheney)

- Sam Boyer. [GitHub](https://github.com/sdboyer), [Twitter](https://twitter.com/sdboyer)

- Fillippo Valsorda. [Website](https://filippo.io/), [GitHub](https://github.com/FiloSottile), [Twitter](https://twitter.com/FiloSottile)
  + [talk/filo2016](https://www.youtube.com/watch?v=lhMhApWQp2E) 从 cgo 回到 Go。2016年7月12日。
  + [talk/filo2017](https://speakerdeck.com/filosottile/calling-rust-from-go-without-cgo-at-gothamgo-2017) 不使用 cgo，从 Go 到 Rust。
  + [talk/filo2018](https://speakerdeck.com/filosottile/why-cgo-is-slow-at-capitalgo-2018) 为什么 cgo 太慢。2018年 CapitalGo。
  + [talk/speakerdeck](https://speakerdeck.com/filosottile?page=1)

> 更多人和谈话应该被添加……

[Back To Top](#top)

### 小组会谈

- [talk/goteam2012](https://www.youtube.com/watch?v=sln-gJaURzk) Go 团队集会。2012年谷歌网络开发者大会。2012年7月2日。
- [talk/goteam2013](https://www.youtube.com/watch?v=p9VUCp98ay4) 和 Go 团队的炉边谈话。2013年谷歌网络开发者大会。2013年5月18日。
- [talk/goteam2014](https://www.youtube.com/watch?v=u-kkf76TDHE) 和 Blake Mizerany 在 Gophers 工作室。2014年 GopherCon。2014年5月21日。
- [talk/goteam2019](https://www.youtube.com/watch?v=3yghHvvZQmA) 认识作者：Go 语言。2019年 Cloud Next 大会，2019年4月10日。
- [talk/goteam2020a](https://www.youtube.com/watch?v=gJxvkOHpTSM) 2020年 GoLab：Go 团队问答。2020年10月22日。
- [talk/goteam2020b](https://www.youtube.com/watch?v=BNHwHLNLjLs) 2020年 GopherCon：Go 团队问答。2020年11月16日。

[Back To Top](#top)

## 时间线

时间线能帮助你确定关联到 Go 版本文档。

| 版本 | 发布预期/实际时间 | 距离上一次发布天数 (+Delay) |
|:--|:--|:--|
| Go 1    | - / 2012.03.28 | - |
| Go 1.1  | - / 2013.05.13 | 440 |
| Go 1.2  | - / 2013.12.01 | 202 |
| Go 1.3  | - / 2014.06.18 | 199 |
| Go 1.4  | - / 2014.12.10 | 175 |
| Go 1.5  | 2015.07.31 / 2015.08.19 | 252 (+19) |
| Go 1.6  | 2016.01.31 / 2016.02.17 | 182 (+17) |
| Go 1.7  | 2016.07.31 / 2016.08.15 | 180 (+15) |
| Go 1.8  | 2017.01.31 / 2017.02.16 | 185 (+16) |
| Go 1.9  | 2017.07.31 / 2017.08.24 | 189 (+24) |
| Go 1.10 | 2018.01.31 / 2018.02.16 | 176 (+16) |
| Go 1.11 | 2018.07.31 / 2018.08.24 | 189 (+24) |
| Go 1.12 | 2019.01.31 / 2019.02.25 | 185 (+25) |
| Go 1.13 | 2019.07.31 / 2019.09.03 | 190 (+34) |
| Go 1.14 | 2020.01.31 / 2020.02.25 | 175 (+25) |
| Go 1.15 | 2020.07.31 / 2020.08.11 | 168 (+11) |
| Go 1.16 | 2021.01.31 / 2021.02.16 | 189 (+16) |
| Go 1.17 | 2021.07.31 / 2021.08.16 | 181 (+16) |
| Go 1.18 | 2022.01.31 / 2022.03.15 | 196 (+43) |
| Go 1.19 | 2022.07.31 / 2022.08.02 | 140 (+2)  |
| Go 1.20 | 2023.01.31 / 2023.02.01 | 183 (+1)  |
| Go 1.21 | 2023.07.31 / 2023.08.08 | 188 (+8)  |

历史版本说明可以提供一些大概信息：

- [doc/go1release](https://go.dev/doc/devel/release.html) Go 发布历史
- [doc/go1prerelease](https://go.dev/doc/devel/pre_go1.html) Go 1 预发布历史
- [doc/go0release](https://go.dev/doc/devel/weekly.html) 每周发布历史（Go 1 之前）

[Back To Top](#top)

## 语言设计

### Misc

- [design/go0initial](https://github.com/golang/go/blob/18c5b488a3b2e218c0e0cf2a7d4820d9da93a554/doc/go_spec) Rob Pike、Robert Griesemer、Ken Thompson，Go 语言注释规范，2008年3月3日。
- [design/go0spec0](https://github.com/golang/go/blob/e6626dafa8de8a0efae351e85cf96f0c683e0a4f/doc/go_lang.txt) Go 编程语言，语言规范。2008年3月7日。
- [design/go0semicolon](https://go.dev/s/semicolon-proposal) Rob Pike，Go 中的分号。2009年12月10日。
- [design/go11func](https://go.dev/s/go11func) Russ Cox，Go 1.11 函数调用。2013年2月。
- [design/go11return](https://go.dev/s/go11return) Russ Cox，Go 函数最后的 Return 要求。2013年3月。
- [design/go12nil](https://go.dev/s/go12nil) Russ Cox，Go 1.2 字段选择和空检查。2013年7月。
- [doc/go13todo](https://go.dev/s/go13todo) Go 1.3 待完成列表。2014年6月1日。
- [doc/goatgoogle](https://go.dev/talks/2012/splash.article#TOC_12.) Rob Pike，谷歌 Go 使用 - 语义。2012年10月25日。
- [doc/makego](https://go.dev/talks/2015/how-go-was-made.slide) Andrew Gerrand，Go 怎样创建的。2015年7月9日。
- [discuss/go1preview](https://docs.google.com/document/pub?id=1ny8uI-_BHrDCZv_zNBSthNKAMX_fR_0dc6epA6lztRE) Russ Cox。Go 1 预览版。 2011年。
- [design/overlapping-interfaces](https://go.dev/design/6977-overlapping-interfaces) Robert Griesemer 提案：允许将接口嵌入折叠方法集。2019年10月16日。
  + [issue/6977](https://go.dev/issue/6977) 规则：允许嵌入重叠接口
- [design/struct-conversion](https://go.dev/design/16085-conversions-ignore-tags) Robert Griesemer 提案：struct 类型转换忽略 tag。2016年6月16日。
  + [issue/16085](https://go.dev/issue/16085) 提案：struct 类型转换忽略 tag
- [design/go2trans](https://go.dev/design/28221-go2-transitions) Ian Lance Taylor 提案：Go 2 变迁。2018年10月15日。
- [design/signed-int-shift](https://go.dev/design/19113-signed-shift-counts) Robert Griesemer 提案：在 Go 2 中允许有符号整数进行移位计算。2019年1月17日。
  + [issue/19113](https://go.dev/issue/19113) 提案：规范：允许有符号整数进行移位计算。
- [design/number-literal](https://go.dev/design/19308-number-literals) Russ Cox、Robert Griesemer 提案：Go 2 数学字面量。2019年3月6日。
  + [issue/12711](https://go.dev/issue/12711) 提案：不同的八进制字面量表示
  + [issue/19308](https://go.dev/issue/19308) 提案：规范：二进制字面量
  + [issue/28493](https://go.dev/issue/28493) 提案：允许在数字中使用 `_`
  + [issue/29008](https://go.dev/issue/29008) 提案：Go 2 十六进制浮点数
- [issue/33502](https://go.dev/issue/33502) 提案：审查会议记录
- [issue/33892](https://go.dev/issue/33892) 提案：审查 Go 2 会议记录
- [issue/19623](https://go.dev/issue/19623) 提案：规范：更改 int 为任意精度
- [issue/19367](https://go.dev/issue/19367) unsafe：添加 `Slice(ptr *T, len anyIntegerType) []T`
- [issue/40481](https://go.dev/issue/40481) unsafe：添加函数

[Back To Top](#top)

### 切片 (1.2)

- [design/read-only-slices](https://docs.google.com/document/d/1UKu_do3FRvfeN5Bb1RxLohV-zBOJWTzX0E8ZU1bkqX0/edit#heading=h.2wzvdd6vdi83) Brad Fitzpatrick，只读切片。2013年5月13日。
- [design/read-only-slices-russ](https://docs.google.com/document/d/1-NzIYu0qnnsshMBpMPmuO21qd8unlimHgKjRD9qwp2A/edit) Russ Cox，只读切片的评价。2013年5月。
- [design/go12slice](https://go.dev/s/go12slice) Russ Cox，Go 切片的容量。2013年6月。
- [design/multidim-slice](https://go.dev/design/6282-table-data) Brendan Tracey，提案：多维切片。2016年11月17日。
- [issue/41239](https://go.dev/issue/41239) 运行时：`append`的增长让人意外。
- [discuss/why-slice-grow](https://groups.google.com/g/golang-nuts/c/UaVlMQ8Nz3o) 为什么切片长度会在 1024 后以25%的速度增长？
- [cl/347917](https://go.dev/cl/347917) 运行时：让切片增长公式更平滑。
  + [doc/cl-347917-graph](https://docs.google.com/document/d/1JQvV6vyAYdHhIboY-zAwK06OXZjxHrUhOFeG38MuJ94/edit?resourcekey=0-L5OsHqwZZBxvjfK0dwsyVQ) CL 347917 图表

[Back To Top](#top)

### 包管理 (1.4, 1.5, 1.7)

- [design/go14internal](https://go.dev/s/go14internal) Russ Cox，Go 1.4 `Internal` 包，2014年6月。
- [design/go14nopkg](https://go.dev/s/go14nopkg) Russ Cox，Go 1.4 `src/pkg` → `src`，2014年6月。
- [design/go14customimport](https://go.dev/s/go14customimport) Russ Cox. Go 1.4 自定义路径导入检查。2014年6月。
- [design/go15vendor](https://go.dev/s/go15vendor) Russ Cox，Go 1.5 Vendor 实验，2015年7月。
- [design/go17binarypkg](https://go.dev/design/2775-binary-only-packages) Russ Cox，提案：纯二进制包，2016年4月24日。
  + [issue/2775](https://go.dev/issue/2775) cmd/go：当二进制可用但源文件丢失。

[Back To Top](#top)

### 类型别名 (1.9)

- [design/type-alias](https://go.dev/design/18130-type-alias) Russ Cox、Robert Griesemer 提案：类型别名。2016年12月16日。
  + [talk/type-alias](https://www.youtube.com/watch?v=t-w6MyI2qlU) 2016年 GopherCon —— 快速谈话：Robert Griesemer - Go 别名说明，建议。2016年10月9日。
  + [issue/16339](https://go.dev/issue/16339) 提案：Go 别名说明。
  + [issue/18130](https://go.dev/issue/18130) 所有：支持渐进式代码修复，同时在包之间移动类型。
- [talk/refactor-video](https://www.youtube.com/watch?v=h6Cw9iCDVcU) Russ Cox，重构代码库（在 Go 的帮助下）。2016年 GothamGo，2016年11月18日。
  + [doc/refactor](https://talks.go.dev/2016/refactor.article) Russ Cox，重构代码库（在 Go 的帮助下）。

[Back To Top](#top)

### Defer (1.14)

- [design/open-defer](https://go.dev/design/34481-opencoded-defers) Dan Scales、Keith Randall、and Austin Clements 提案：通过内联代码进行低成本 defer，以及额外管理 panic。2019年9月23日。
  + [issue/6980](https://go.dev/issue/6980) cmd/compile：在栈帧中分配一些 defer。
  + [issue/14939](https://go.dev/issue/14939) 运行时：defer 很慢
- 未解决的 `defer recover()`边缘案例
  + [issue/10458](https://go.dev/issue/10458) 规范：panic 在极端情况下的语义
  + [issue/23531](https://go.dev/issue/23531) 规范：在嵌套 defer 中使用 `recover()`
  + [issue/26275](https://go.dev/issue/26275) 规范：在使用 defer 的函数中记录调用者的行为
  + [issue/34530](https://go.dev/issue/34530) 规范：澄清何时调用 recover 停止 panic
  + [cl/189377](https://go.dev/cl/189377) 规范：列举 recover 行为和递归 panic 的详情。

[Back To Top](#top)

### 错误值 (1.13)

- [doc/err2011](https://go.dev/blog/error-handling-and-go) Andrew Gerrand，Go 错误处理。2011年7月。
- [doc/err-values](https://go.dev/blog/errors-are-values) Rob Pike。错误是值，2015年1月。
- [doc/err-philosophy](https://dave.cheney.net/paste/gocon-spring-2016.pdf) Dave Cheney，我处理错误的理念。2016年4月。
- [doc/err-gracefully](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully) Dave Cheney，不要只检查错误，而是优雅处理。2016年4月。
- [doc/err-stacktrace](https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package) Dave Cheney，堆栈跟踪和错误包，2016年6月12日。
- [doc/err-upspin](https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html) Rob Pike，Upspin 的错误处理。2017年12月6日。
- [doc/err-work](https://go.dev/blog/go1.13-errors) Damien Neil 和 Jonathan Amsterdam，Go 1.13 中处理错误，2019年10月17日。
- [design/err-handling-overview](https://go.dev/design/go2draft-error-handling-overview) Russ Cox，错误处理——问题综述。
- [doc/err-value-faq](https://github.com/golang/go/wiki/ErrorValueFAQ) Jonathan Amsterdam 和 Bryan C. Mills 错误值：常见问题。2019年8月。
- [design/err-handle-check](https://go.dev/design/go2draft-error-handling) Marcel van Lohuizen，错误处理——设计草稿。2018年8月27日。
- [design/err-try](https://go.dev/design/32437-try-builtin) Robert Griesemer 提案：Go 内置错误检查函数 `try`, 2019年6月12日。
  + [issue/32437](https://go.dev/issue/32437#issuecomment-512035919) 提案：Go 内置错误检查函数 `try`。判定回复。
- [design/err-inspect](https://go.dev/design/go2draft-error-inspection) Jonathan Amsterdam、Damien Neil，错误检查——设计草稿，2018年8月27日。
- [design/err-values-overview](https://go.dev/design/go2draft-error-values-overview) Russ Cox，错误处理——问题综述。2018年8月27日。
- [design/error-values](https://go.dev/design/29934-error-values) Jonathan Amsterdam、Russ Cox、Marcel van Lohuizen、Damien Neil 提案：Go 2 错误检查。2019年1月25日。
  + [issue/29934](https://go.dev/issue/29934) Jonathan Amsterdam 提案：Go 2 错误检查。2019年1月25日。
  + [issue/29934-decision](https://go.dev/issue/29934#issuecomment-489682919) Damien Neil。Go 1.13 关于错误值的决定。2019年5月6日。
  + [issue/29934-russ](https://go.dev/issue/29934#issuecomment-490087200) Russ Cox，关于“提案：Go 2 错误检查”的回复。2019年5月7日。
- [design/err-print](https://go.dev/design/go2draft-error-printing) Marcel van Lohuizen，错误打印——设计草稿。2018年8月27日。
  + [issue/30468](https://go.dev/issue/30468) errors: 新版本的性能衰退。
- [issue/40432](https://go.dev/issue/40432) 语言：Go 2: 错误处理的讨论
- [issue/40776](https://go.dev/issue/40776) 提案：动态错误忽略的检测器
- [issue/41198](https://go.dev/issue/41198) 提案：errors：添加 ErrUnimplemented 作为失败接口方法的标准方式。

[Back To Top](#top)

### 通道、选择器

- [design/lockfree-channels](https://docs.google.com/a/google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub) Dmitry Vyukov，Go 通道。2014年1月28日。
  + [issue/8899](https://go.dev/issue/8899) 运行时：无锁通道。
  + [discuss/lockfree-channels](https://groups.google.com/g/golang-dev/c/0IElw_BbTrk/m/cGHMdNoHGQEJ) 无锁通道的更新。
  + [cl/112990043](https://codereview.appspot.com/112990043/) 运行时：选择器中的锁粒度
  + [cl/110580043](https://codereview.appspot.com/110580043/) 运行时：在非阻塞通道操作中添加快速路径
- [issue/8898](https://go.dev/issue/8898) 运行时：特殊案例，计时器通道。
- [issue/37196](https://go.dev/issue/37196) 时间：在停止或重置返回后，让 Timer/Ticker 通道不接受旧值。
- [issue/8903](https://go.dev/issue/8903) 运行时：让通道更快生成。
- [issue/21806](https://go.dev/issue/21806) 选择语句的公平性。
- [issue/40410](https://go.dev/issue/40410) 从 scase 中去除不必要的字段
- [issue/40641](https://go.dev/issue/40641) 运行时，在堆栈收缩和通道发送/接受之间的竞争导致错误的 sudog 值
- [issue/37350](https://go.dev/issue/37350) 反射：如果数组长度大于 1<< 16，请 panic

[Back To Top](#top)

### 泛型

- [doc/generics-discuss](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit#heading=h.vuko0u3txoew) Go 泛型讨论摘要
- [doc/generics-dilemma](https://research.swtch.com/generic) Russ Cox，对泛型很犹豫。2009年12月3日。
- [design/type-functions](https://go.dev/design/15292/2010-06-type-functions) Ian Lance Taylor，类型函数。2010年6月。
- [design/generalized-types](https://go.dev/design/15292/2011-03-gen) Ian Lance Taylor，通用类型。2011年3月。
- [design/code-gen](https://docs.google.com/document/pub?id=1IXHI5Jr9k4zDdmUhcZImH59bOUK0G325J1FY6hdelcM) Russ Cox，Go 中动态代码生成的替代。2012年9月。
- [design/generalized-types2](https://go.dev/design/15292/2013-10-gen) Ian Lance Taylor，Go 中的通用类型，2013年10月。
- [design/type-parameters](https://go.dev/design/15292/2013-12-type-params) Ian Lance Taylor，Go 中的类型参数，2013年12月。
- [design/compile-time-function](https://go.dev/design/15292/2016-09-compile-time-functions) Bryan C. Mills，编译时函数和一等类型。2016年9月。
- [design/should-generics](https://github.com/golang/proposal/blob/b571c3273d2c6988d24a22dd1c529387ff05962a/design/15292-generics) Ian Lance Taylor，Go 应该有泛型。2011年1月。
- [design/should-generics2](https://go.dev/design/15292-generics) Ian Lance Taylor，Go 应该有泛型。更新：2016年4月。
  + [issue/15292](https://go.dev/issue/15292) 提案：规范：通用编程工具。
- [design/generics-overview](https://go.dev/design/go2draft-generics-overview) Russ Cox，泛型——问题综述。2018年8月27日。
- [design/contracts](https://go.dev/design/go2draft-contracts) Ian Lance Taylor, Robert Griesemer，合同——设计草案。2018年8月27日，更新：2019年7月31日。
  + [cl/187317](https://go.dev/cl/187317/) 原型实现
  + [paper/featherweight-go](https://arxiv.org/abs/2005.11710) Griesemer, Robert 等，轻量级 Go。arXiv 预印本 arXiv:2005.11710 (2020).
  + [talk/featherweight-go](https://www.youtube.com/watch?v=Dq0WFigax_c) Phil Wadler：轻量级 Go，2020年6月8日。
- [design/type-parameters2](https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md) Ian Lance Taylor, Robert Griesemer。类型参数——设计草稿。2016年6月16日，更新：2020年8月28日。
  + [cl/dev.go2go](https://github.com/golang/go/blob/dev.go2go/README.go2go.md) dev.go2go 分支
  + [doc/type-check-readme](https://github.com/golang/go/tree/dev.go2go/src/go/types) 类型检查
  + [doc/type-check-notes](https://github.com/golang/go/blob/dev.go2go/src/go/types/NOTES) 这个文件服务器作为笔记或实现日志
- [discuss/generics-parenthesis](https://groups.google.com/g/golang-nuts/c/7t-Q2vt60J8) Robert，泛型和括号
- [issue/33232](https://go.dev/issue/33232) 提案：Go 2：为 interface{} 添加任意别名
- [discuss/generics-move](https://groups.google.com/g/golang-nuts/c/iAD0NBz3DYw) Ian，继续泛型设计。
- [discuss/generics-implementation](https://groups.google.com/g/golang-dev/c/OcW0ATRS4oM) 实现泛型
- [design/generics-implementation-stenciling](https://go.dev/design/generics-implementation-stenciling) 泛型实现——模板
- [design/generics-implementation-dictionaries](https://go.dev/design/generics-implementation-dictionaries) 泛型实现——字典
- [issue/43651](https://go.dev/issue/43651) 提案：规范：使用类型参数添加泛型编程
- [design/type-parameters3](https://go.dev/design/43651-type-parameters) 类型参数建议
- [issue/45346](https://go.dev/issue/45346) 提案：规范：泛型：使用类型集合删除类型中的类型关键字
- [issue/46477](https://go.dev/issue/46477) 提案：规范：泛型：别名中的类型参数
- 使用泛型的标准库
  + [issue/45458](https://go.dev/issue/45458) 提案：约束：定义标准类型参数约束的新包
  + [discuss/47319](https://github.com/golang/go/discussions/47319) 提案：约束：定义标准类型参数约束的新包（讨论）
  + [issue/45955](https://go.dev/issue/45955) 提案：切片：提供泛型切片函数的新包
  + [discuss/47203](https://github.com/golang/go/discussions/47203) 提案：切片：提供泛型切片函数的新包（讨论）
  + [discuss/47331](https://github.com/golang/go/discussions/47331) 提案：容器/集合：提供泛型集合类型的新包（讨论）
  + [discuss/47330](https://github.com/golang/go/discussions/47330) 提案：maps：提供泛型 map 函数的新包（讨论）
  + [issue/47657](https://go.dev/issue/47657) 提案：sync，sync/atomic：添加 PoolOf, MapOf, ValueOf

[Back To Top](#top)

## 编译工具链

### 编译

- [code/gc0initial](https://github.com/golang/go/tree/cb87526ce3531557ccf69969de4c8018956b10b5/src/c) Ken Thompson，Go 0 编译器初始版本，2008年3月28日。
- [code/6g](https://github.com/golang/go/commit/0cafb9ea3d3d34627e8f492ccafa6ba9b633a213) Rob Pike，Go 0 第一个完整的编译器，2008年6月4日。
- [design/go12symtab](https://go.dev/s/go12symtab) Russ Cox，Go 1.2 运行时符号信息，2013年7月。
- [design/go13compiler](https://go.dev/s/go13compiler) Russ Cox，Go 1.3+ 编译器大修，2013年12月。
- [design/go14generate](https://go.dev/s/go1.4-generate) Rob Pike，Go 生成：提案。
- [design/dev.cc](https://go.dev/s/dev.cc) Russ Cox，dev.cc 分支计划，2014年11月
- [design/go15bootstrap](https://go.dev/s/go15bootstrap) Russ Cox，Go 1.5 启动计划，2015年1月。
- [doc/escape-analysis](https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/edit#) Dmitry Vyukov，Go 逃逸分析缺陷，2015年2月10日。
- [design/execmodes](https://go.dev/s/execmodes) Ian Lance Taylor，Go 执行模式，2015年8月（2016年1月更新）
- [design/go17ssa](https://go.dev/s/go17ssa) Keith Randall，Go 编译器新的 SSA 后端。2015年2月10日。
- [doc/compiler-optimization](https://github.com/golang/go/wiki/CompilerOptimizations) 编译器和运行时优化。
- [issue/6853](https://go.dev/issue/6853) 所有：二进制文件太大且不断增长。
- [design/go19inlining](https://go.dev/design/19348-midstack-inlining) David Lazar, Austin Clements，提案：Go 编译器中内联中层堆栈。
  + [issue/19348](https://go.dev/issue/19348) cmd/compile：允许中层堆栈内联
  + [talk/go19inliningtalk](https://go.dev/s/go19inliningtalk) David Lazar，Go 编译器中层堆栈内联
- [design/dwarf-inlining](https://go.dev/design/22080-dwarf-inlining) Than McIntosh，提案：在 Go 编译器中发出 DWARF 内联信息
  + [issue/22080](https://go.dev/issue/22080) cmd/compile：生成 DWARF 内联信息
- [issue/23109](https://go.dev/issue/23109) cmd/compile：重写逃逸分析
- [issue/27167](https://go.dev/issue/27167) cmd/compile：重命名很多东西
  + [doc/renames](https://docs.google.com/document/d/19_ExiylD9MRfeAjKIfEsMU1_RGhuxB9sA0b5Zv7byVI/edit) 提案：Go 1.12 工具链重命名
- GOEXPERIMENT=checkptr
  + [issue/22218](https://go.dev/issue/22218) 提案：添加 GOEXPERIMENT=checkptr
  + [issue/34964](https://go.dev/issue/34964) cmd/compile: 允许 -d=checkptr 作为 -race and/or -msan 的一部分?
  + [issue/34972](https://go.dev/issue/34972) 所有：通过 -d=checkptr 获取标准库构建
  + [discuss/checkptr](https://groups.google.com/forum/#!msg/golang-dev/SzwDoqoRVJA/Iozu8vWdDwAJ)
- [issue/37121](https://go.dev/issue/37121) 运行时：在 Intel 中，未对齐的跳转造成性能下降
- [issue/16798](https://go.dev/issue/16798) 提案：cmd/compile：仅为自递归添加尾部调用优化（已拒绝）
- [issue/22624](https://go.dev/issue/22624) 提案：Go 2：添加 become 语句来支持尾部调用（已拒绝）
- [design/64align](https://go.dev/design/36606-64-bit-field-alignment) Dan Scales，提案：在32位系统上使64位字段作为64位对齐，添加 //go:packed，//go:align 指令，2020年6月8日。
  + [issue/599](https://go.dev/issue/599) cmd/compile: 在32位系统上使64位字段作为64位对齐
  + [issue/36606](https://go.dev/issue/36606) 提案：cmd/compile: 在32位系统上使64位字段作为64位对齐，在结构体上添加 //go:packed，//go:align 指令
- [talk/gccgo](https://www.youtube.com/watch?v=U0w9eFunkX4) gccgo 的简要概述，“另一个” Go 编译器。2015年8月6日。
- [issue/28262](https://go.dev/issue/28262) cmd/compile：反馈导向优化

[Back To Top](#top)

### 连接器

Ken Thompson 编写了 Go 连接器，Russ 在 Go 1.3 中进行了一些大修。Austin 和 keith, Than, Cheery 和其他人一起对连接器返工，将在 Go 1.15 和 Go 1.16 中发布

- [design/go13linker](https://go.dev/s/go13linker) Russ Cox，Go 1.3 连接器大修，2013年11月。
- [design/go116linker](https://go.dev/s/better-linker) Austin Clements，构建更好的 Go 连接器，2019年9月12日。

[Back To Top](#top)

### 调试器

- [doc/go13heapdump](https://go.dev/s/go13heapdump) 堆转储 Go 1.3
- [doc/go14heapdump](https://github.com/golang/go/wiki/heapdump14) 堆转储 Go 1.4
- [doc/go15heapdump](https://github.com/golang/go/wiki/heapdump15-through-heapdump17) 堆转储 Go 1.5 到 堆转储 Go 1.7
- [design/heap-viewer](https://go.dev/design/16410-heap-viewer) Michael Matloob，提案：Go 堆转储查看器，2016年7月20日。
  + [issue/16410](https://go.dev/issue/16410) x/tools/cmd/heapdump：创建一个堆转储查看器
- [design/profiler-labels](https://go.dev/design/17280-profile-labels) Michael Matloob，提案：支持 pprof 探查器标签，2017年3月15日。
  + [issue/17280](https://go.dev/issue/17280) pprof：添加探查器标签支持

[Back To Top](#top)

### 竞争检测器

- [issue/42598](https://go.dev/issue/42598) runtime: apparent false-positive race report for a buffered channel after CL 220419

[Back To Top](#top)

### 跟踪器

- [design/go15trace](https://go.dev/s/go15trace) Dmitry Vyukov，Go 执行跟踪器，2014年10月。
- [design/tracefmt](https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview#heading=h.yr4qxyxotyw) nduca@, dsinclair@，跟踪事件格式，2016年10月。

[Back To Top](#top)

### 锁分析

- [issue/38029](https://go.dev/issue/38029) x/build: linux-amd64-staticlockranking 持续失败。
  + [cl/192704](https://go.dev/cl/192704) 运行时：锁操作日志支持
  + [cl/207348](https://go.dev/cl/207348) 运行时：当运行 timer 时释放 timersLock
  + [cl/207846](https://go.dev/cl/207846) 运行时，在跟踪内存代码时避免潜在的死锁
  + [cl/207619](https://go.dev/cl/207619) 运行时：运行时的静态锁等级（通过 GOEXPERIMENT 开启）
  + [cl/222925](https://go.dev/cl/222925) cmd/go: 为任何已启用的 GOEXPERIMENT 定义构建标志
  + [cl/228417](https://go.dev/cl/228417) 运行时：将 Gscan 的合并/释放合并到锁排名顺序中
  + [cl/229480](https://go.dev/cl/229480) 运行时：添加几个新的 lock-rank partial order edges
  + [cl/231463](https://go.dev/cl/231463) 运行时：添加一个额外的 lock ranking partial edge
  + [cl/233599](https://go.dev/cl/233599) 运行时：添加 partial order edge 的锁（assistQueue -> mspanSpecial）
  + [cl/236137](https://go.dev/cl/236137) 运行时：为锁排名3个新的 partial orders
- [issue/40677](https://go.dev/issue/40677) 运行时：锁保持检查

[Back To Top](#top)

### 构建器

- [design/go13nacl](https://go.dev/s/go13nacl) Russ Cox，Go 1.3 本地客户端支持。2013年10月。
- [design/gobuilder](http://go.dev/s/builderplan) Brad Fitzpatrick，Go 构建计划。2014年9月3日。
  + [discuss/gobuilder](https://groups.google.com/g/golang-dev/c/sdFD0-2Ed8k) 构建器运行的变更
- [design/go14android](https://go.dev/s/go14android) David Crawshaw，Go 支持安卓。2014年6月。
- [design/go-generate](https://go.dev/s/go1.4-generate) Rob Pike，Go 生成，2014年1月。
- [issue/13560](https://go.dev/issue/13560) 提案：构建：定义识别机器生成的文件的标准方式。
- [discuss/generatedcode](https://go.dev/s/generatedcode) Rob Pike 的关于 Issue 13560 的最终意见。
- [design/goenv](https://go.dev/design/30411-env) Russ Cox，提案：Go 命令行配置文件。2019年3月1日。
  + [issue/30411](https://go.dev/issue/30411) proposal: cmd/go: 添加 `go env -w`设置默认环境变量
- [design/go116build](https://go.dev/s/go-build-design%E2%80%8B) Russ Cox，防 Bug 构建约束——设计草稿。2020年6月30日。
  + [issue/41184](https://go.dev/issue/41184) cmd/go: 持续交流防 Bug //go:build
- Windows
  + [issue/41191](https://go.dev/issue/41191#issuecomment-690887303) 工具链指令
  + [discuss/win2000-golang-nuts](https://go.dev/s/win2000-golang-nuts) 反对删除对 Windows 2000(x86-32)的支持
- [design/wasm](https://docs.google.com/document/d/131vjr4DH6JFnb-blm_uRdaC0_Nv3OUwjEY5qVCxCup4/edit#heading=h.mjo1bish3xni) Richard Musiol，Go WebAssembly 的架构。2018年2月28日。
- [design/wasm2](https://docs.google.com/document/d/1GRmy3rA4DiYtBlX-I1Jr_iHykbX8EixC3Mq0TCYqbKc/edit#heading=h.q4c21ihutzk0) WebAssembly 程序文件

[Back To Top](#top)

### 模块

- [design/go-dep](https://docs.google.com/document/d/18tNd8r5DV0yluCR7tPvkMTsWD_lYcRO7NhpNSDymRr8) Go 打包的建议流程
- [design/go-dep2](https://docs.google.com/document/d/1qnmjwfMmvSCDaY4jxPmLAccaaUI5FfySNE90gB0pTKQ/edit) 依赖管理工具
  + [doc/go-dep](https://golang.design/history/6https://blog.gopheracademy.com/advent-2016/saga-go-dependency-management/) Sam Boyer，Go 依赖管理事迹。2016年12月13日。
  + [talk/go-dep](https://www.youtube.com/watch?v=5LtMb090AZI) GopherCon 2017：Sam Boyer，Go 依赖管理的新时代。2017年7月24日。
  + [talk/go-dep-design](https://www.youtube.com/watch?v=wBTGd_dvnO8) dotGo 2017：sam boyer， 依赖的功能设计。2017年12月8日。
  + [discuss/go-dep](https://www.youtube.com/watch?v=sbrZfPgNmfw) Russ Cox，Jess Frazelle, Sam Boyer, Pete Garcin，构建时添加可预测性。2018年2月22日。
- [design/vgo](https://go.dev/design/24301-versioned-go) Russ Cox，提案：Go 模块版本化。2018年3月20日。
  + [issue/24301](https://go.dev/issue/24301) cmd/go: 像 Go 工具链添加包版本支持。
  + [doc/deps](https://research.swtch.com/deps) Russ Cox，我们的软件依赖问题。2019年1月23日。
  + [doc/vgo](https://research.swtch.com/vgo) Russ Cox，Go 和版本化。
  + [discuss/groups-gomod](https://groups.google.com/g/golang-dev/c/a5PqQuBljF4) Go 模块化来了。
  + [discuss/go-dep-response](https://www.reddit.com/r/golang/comments/92f3q1/peter_bourgon_a_response_about_dep_and_vgo/) Reddit 讨论。
  + [doc/go-dep-response](https://peter.bourgon.org/blog/2018/07/27/a-response-about-dep-and-vgo.html) Peter Bourgon，关于 dep 和 vgo 的回应。2018年7月27日。
  + [discuss/go-dep-response2](https://news.ycombinator.com/item?id=17628311) 黑客新闻：关于 dep 和 vgo 的回应。
  + [discuss/go-dep-twitter](https://twitter.com/_rsc/status/1022588240501661696) Russ Cox 的推特风暴。
- [design/sumdb](https://go.dev/design/25530-sumdb) Russ Cox, Filippo Valsorda，提案：公共 Go 模块生态的安全性。2019年4月24日。
  + [issue/25530](https://go.dev/issue/25530) 提案：cmd/go: 透明日志的安全版本。
- [issue/23966](https://go.dev/issue/23966#issuecomment-377997161) 为什么 go.mod 要定制语法？
- [design/lazy-gomod](https://go.dev/design/36460-lazy-module-loading) Bryan C. Mills，提案：模块的延迟加载。2020年2月20日。
- [issue/45713](https://go.dev/issue/45713) 提案：cmd/go: 添加工作区模式
  + [design/workspace](https://go.dev/design/45713-workspace) 提案：cmd/go 多模块工作区

[Back To Top](#top)

### gopls

- [design/gopls-workspace](https://go.dev/design/37720-gopls-workspaces) Heschi Kreinick, Rebecca Stambler，提案：多项目 gopls 工作区，2020年3月9日。

[Back To Top](#top)

### 测试，x/perf

- [design/subtests](https://go.dev/design/12166-subtests) Marcel van Lohuizen，测试：计划中的子测试和子基准测试支持。2015年9月2日。
  + [issue/12166](https://go.dev/issue/12166) 测试：计划中的子测试和子基准测试支持。
- [design/gotest-bench](https://go.dev/design/14313-benchmark-format) Russ Cox, Austin Clements，提案：Go 基准测试数据格式。2016年2月。
  + [issue/14313](https://go.dev/issue/14313) cmd/go: 决定，标准基准数据格式的文档。
- [issue/20875](https://go.dev/issue/20875) 测试：考虑在基准测试时减少调用 ReadmemStats
- [issue/27217](https://go.dev/issue/27217) 测试：带有 StopTimer 的小型基准测试永久运行。
- [issue/41637](https://go.dev/issue/41637) 测试：基准测试迭代报告错误。
- [issue/41641](https://go.dev/issue/41641) 测出：中断计时器时基准测试不一致。
- [design/gotest-json](https://go.dev/design/2981-go-test-json) Nodir Turakulov，提案：go test 的 -json 标记。
- [design/testing-helper](https://go.dev/design/4899-testing-helper) Caleb Spare，提案：测试：用 TB.Helper 更好地支持测试帮助程序。2016年12月27日。
  + [issue/4899](https://go.dev/issue/4899) 测试：添加 t.Helper 让 file:line 的结果更好用。
- [design/fuzzing](https://go.dev/s/draft-fuzzing-design) Katie Hockman，设计草案：模糊测试的起步。
- [issue/43744](https://go.dev/issue/43744) 测试：基准测试单元属性
- [issue/48803](https://go.dev/issue/48803) 所有：Go 编译/运行时性能监控系统。
- [issue/49121](https://go.dev/issue/49121) x/perf/storage：支持 postgresql。

[Back To Top](#top)

## 运行时核心

### 调度器

- [paper/work-steal](https://dl.acm.org/citation.cfm?id=324234) Robert D. Blumofe 和 Charles E. Leiserson，通过工作窃取调度多线程计算。J. ACM 46, 5 (September 1999), 720-748.
- [cl/sched-m-1](https://github.com/golang/go/commit/96824000ed89d13665f6f24ddc10b3bf812e7f47#diff-1fe527a413d9f1c2e5e22e08e605a192) Russ Cox，清理调度器，2008年8月5日。
- [cl/sched-m-n](https://github.com/golang/go/commit/fe1e49241c04c748d0e3f4762925241adcb8d7da) 现在情况好多了。2009年11月11日。
- [design/go11sched](https://go.dev/s/go11sched) Dmitry Vyukov，可伸缩的 Go 调度器设计文档。2012年
  + [cl/7314062](https://github.com/golang/go/commit/779c45a50700bda0f6ec98429720802e6c1624e8) 运行时：提升的调度器。
- [design/sched-preempt-dmitry](https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.3pilqarbrc9h) Dmitry Vyukov。Go 优先权调度器设计文档。2013年
- [design/sched-numa](https://docs.google.com/document/u/0/d/1d3iI2QWURgDIsSR6G2275vMeQ_X7w-qxM2Vp7iGwwuM/pub) Dmitry Vyukov，Go 的 NUMA 感知调度器。2014年9月。
- [design/go15gomaxprocs](https://go.dev/s/go15gomaxprocs) Russ Cox，Go 1.5 的 GOMAXPROCS 默认值。2015年5月。
- [doc/go17sched](https://www.quora.com/How-does-the-golang-scheduler-work/answer/Ian-Lance-Taylor) Ian Lance Taylor，Go 调度器怎样工作？2016年7月16日。
- [design/sched-preempt-austin](https://go.dev/design/24543-non-cooperative-preemption) Austin Clements，提案：goroutine 抢占竞争。
  + [cl/43050](https://go.dev/cl/43050) cmd/compile：在 amd64 上使用错误分支的循环抢占。
  + [issue/10958](https://go.dev/issue/10958) 运行时：紧密循环应该是可抢占的。
  + [issue/24543](https://go.dev/issue/24543) 运行时：goroutine 抢占竞争。
  + [issue/36365](https://go.dev/issue/36365) 运行时：清理松散结尾上的异步抢占
- [issue/14592](https://go.dev/issue/14592) 运行时：让空闲的系统线程退出。
- [issue/18237](https://go.dev/issue/18237) 运行时：当 goroutine 被经常唤醒时调度很慢。
- [issue/20395](https://go.dev/issue/20395) 运行时：当所属的 goroutine 退出时中断锁住的系统线程。
- [issue/20458](https://go.dev/issue/20458) 提案：运行时：一起调用 LockOSThread、UnlockOSThread
- [issue/21827](https://go.dev/issue/21827) 运行时：使用 runtime.LockOSThread 会造成很大的性能影响。
- [issue/27345](https://go.dev/issue/27345) 运行时：将父 goroutine 的堆栈用于新的 goroutine。
- [issue/28808](https://go.dev/issue/28808) 运行时：当 GOMAXPROCS 很高时调度器工作窃取很慢。
- [issue/32113](https://go.dev/issue/32113) 运行时：减少P流失的优化。
- [issue/44313](https://go.dev/issue/44313) 运行时：已停止的Ms不能成为专用或小数的GC工作者。

[Back To Top](#top)

### 执行栈

- [design/contigstack](https://go.dev/s/contigstacks) 连续堆栈
- [issue/17007](https://go.dev/issue/17007) 运行时：致命错误：就绪状态糟糕的 g->status
- [issue/18138](https://go.dev/issue/18138) 运行时：新的 goroutine 在更多堆栈上花费更多的时间
  + [design/predict-stack-size](https://docs.google.com/document/d/1YDlGIdVTPnmUiTAavlZxBI1d9pwGQgZT7IKFKlIXohQ/edit#) Keith Randall，确定一个好的堆栈起始大小，2021年8月18日。
  + [cl/341990](https://go.dev/cl/341990) 运行时：预测堆栈大小
  + [cl/345889](https://go.dev/cl/345889) 运行时：测量堆栈使用情况；需要的话就启动更大的堆栈
- [issue/26061](https://go.dev/issue/26061) 运行时：g0 stack.lo 有时太慢

[Back To Top](#top)

### 内存分配器

Go 内存分配的实力简述：Russ Cox 在 Go 1 上首次实现了基于 tcmallor 的内存分配器，mcache 缓存在 M 上。然后他修改了分配器，允许使用 16GB 的内存，后来到了128GB。然而，分配器（包括收集器）有很严重的锁竞争，且不可伸缩。在 Dmitry 的可伸缩运行时调度器后，分配器可以直接从P锁竞争中分配（更少）。同时，收集器从独立线程迁移到系统监视器线程。现在，Michael 正致力于提高内存分配器的可伸缩性，例如将收集器迁移到用户线程，基于位图的页分配器，可伸缩的 mcentral。

- [doc/tcmalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html) Sanjay Ghemawat, Paul Menage。TCMalloc : 线程缓存 Malloc，谷歌，2009。
- [design/go113scavenge](https://go.googlesource.com/proposal/+/aa701aae530695d32916b779e048a3e18311a2e3/design/30333-smarter-scavenging.md) Michael Knyszek，提案：智能收集。2019年5月9日。
  + [issue/30333](https://go.dev/issue/30333) 运行时：智能收集
  + [issue/32012](https://go.dev/issue/32012) 运行时：后台收集对小堆过于频繁
  + [issue/31966](https://go.dev/issue/31966) 运行时：后台收集堆栈会显著延迟死锁检测
  + [issue/34047](https://go.dev/issue/34047) 运行时：由 scavenge.lock 引起的潜在死循环
  + [issue/34048](https://go.dev/issue/34048) 运行时：收集器步长无法解释碎片
  + [issue/35788](https://go.dev/issue/35788) 运行时：收集器的效率低于之前
  + [issue/36521](https://go.dev/issue/36521) 运行时：Go 1.12 性能下降
  + [issue/36603](https://go.dev/issue/36603) 运行时：系统经常在不收集的内存上调用
- [design/go114pagealloc](https://go.googlesource.com/proposal/+/a078ea9d72b99dc88fdfd2cb6ee150a8ce202ea2/design/35112-scaling-the-page-allocator.md) Michael Knyszek, Austin Clements，提案：缩放Go 页分配器。2019年10月18日。
  + [issue/35112](https://go.dev/issue/35112) 运行时：页分配器缩放
  + [cl/200439](https://go.dev/cl/200439) 运行时：对触发比例设置下限
- [issue/8885](https://go.dev/issue/8885) 运行时：考虑添加24字节大小的类
- [issue/37487](https://go.dev/issue/37487) 运行时：提高 mcentral 的可扩展性
  + [cl/221182](https://go.dev/cl/221182) 运行时：添加新的 mcentral 实现
- [issue/18155](https://go.dev/issue/18155) 运行时：当没有垃圾时延迟扫描辅助
- [issue/19112](https://go.dev/issue/19112) 运行时：gcControllerState.enlistWorker 死锁
- [issue/23687](https://go.dev/issue/23687) 运行时：在 Linux 上也使用 MADV_FREE
  + [cl/135395](https://go.dev/cl/135395) 运行时：在 Linux 上使用 MADV_FREE（如果可用）
- [issue/29707](https://go.dev/issue/29707) cmd/trace: 无法解析轨迹：无法对事件进行一致的排序
- [issue/35954](https://go.dev/issue/35954) 运行时：句柄更优雅地分配到分配器地址空间的顶部
- [issue/37927](https://go.dev/issue/37927) 运行时：GC 步长在低 GOGC 表现出奇怪行为。
- [issue/38130](https://go.dev/issue/38130) 运行时：页分配器的健全性检查不正确。
- [issue/38404](https://go.dev/issue/38404) 运行时：在 arm64/mips64le 上，STW GC 不工作。
- [issue/38605](https://go.dev/issue/38605) 运行时：pageAlloc.allocToCache 不正确地更新 pageAlloc.searchAddr
- [issue/38617](https://go.dev/issue/38617) 运行时：Go 1.14 中收集器在 Windows 里冻结，因为时间粒度太粗略。
- [issue/38966](https://go.dev/issue/38966) 运行时：aix-ppc64 构建器出现致命错误：“修剪错误”，“地址范围的基准和限制不在同一个内存片段中”
- [issue/39128](https://go.dev/issue/39128) 运行时：从 CL 233497 开始，linux-mips-rtrk 构建器一直因为“修剪错误”而失败。
- [issue/40191](https://go.dev/issue/40191) 运行时：pageAlloc.searchAddr 可能指向不连续堆中的未映射的内存，违反了其不变性
- [issue/40457](https://go.dev/issue/40457) 运行时：runqputbatch 不保护它对 globrunqputbatch 的调用。
- [issue/40641](https://go.dev/issue/40641) 运行时：堆栈收缩和通道收发之前的竞争导致错误的 sudog 值
- [issue/42330](https://go.dev/issue/42330) 运行时：在 Linux 上默认为 MADV_DONTNEED
  + [cl/267100](https://go.dev/cl/267100) 运行时：在 Linux 上默认为 MADV_DONTNEED

[Back To Top](#top)

### 垃圾收集器

- [paper/on-the-fly-gc](https://doi.org/10.1145/359642.359655) Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten 和 E. F. M. Steffens。动态垃圾收集：合作练习。Commun.ACM 21，11（1978年11月），966-975。
- [paper/yuasa-barrier](https://doi.org/10.1016/0164-1212(90)90084-Y) T. Yuasa。通用机器上的实时垃圾收集。J. Syst. Softw. 11,3 （1990年3月），181-198.
- [design/go13gc](https://docs.google.com/document/d/1v4Oqa0WwHunqlb8C3ObL_uNQw3DfSY-ztoA-4wWbKcg/pub) Dmitry Vyukov，更简单和更快速的 Go GC。2014年7月16日。
  + [cl/106260045](https://codereview.appspot.com/106260045) 运行时：更简单和更快速的 Go GC
- [design/go14gc](https://go.dev/s/go14gc) Richard L. Hudson。Go 1.4+ 的垃圾收集计划和路线图。2014年8月6日。
- [design/go15gcpacing](https://go.dev/s/go15gcpacing) Austin Clements。Go 1.5 并发垃圾收集步长。2015年3月10日。
- [discuss/gcpacing](https://groups.google.com/forum/#!topic/golang-dev/YjoG9yJktg4) Austin Clements 等人。关于“提案：垃圾收集器步长”的讨论。2015年3月10日。
- [issue/11970](https://go.dev/issue/11970) 运行时：将 GC 协调器替换为状态机。
- [design/sweep-free-alloc](https://go.dev/design/12800-sweep-free-alloc) Austin Clements。提案：密集标记位和无扫描分配。2015年9月30日。
- [issue/12800](https://go.dev/issue/12800) 运行时：将空间的列表替换为直接的位图分配。
- [design/decentralized-gc](https://go.dev/design/11970-decentralized-gc) Austin Clements。提案：分散的GC协调器。2015年10月25日。
- [issue/12967](https://go.dev/issue/12967#issuecomment-171466238) 运行时：标记终止时的收缩堆栈显著增加了 GC 的 STW 时间
- [issue/14951](https://go.dev/issue/14951) 运行时：突变的辅助过于激进，尤其是在高 GC 时。
- [design/eliminate-rescan](https://go.dev/design/17503-eliminate-rescan) Austin Clements, Rick Hudson。消除 STW 堆栈的再次扫描。2016年10月21日。
  + [issue/17503](https://go.dev/issue/17503) 运行时：消除堆栈再扫描。
- [design/concurrent-rescan](https://go.dev/design/17505-concurrent-rescan) Austin Clements, Rick Hudson。提案：堆栈的并发再扫描。2016年10月18日。
  + [issue/17505](https://go.dev/issue/17505) 运行时：堆栈并发再扫描。
- [design/soft-heap-limit](https://go.dev/design/14951-soft-heap-limit) Austin Clements。提案：分开软硬堆大小目标。2018年7月12日。
- [issue/22460](https://go.dev/issue/22460) 运行时：优化写入屏障。
- [design/roc](https://go.dev/s/gctoc) 面向请求的收集器算法（ROC）
  + [cl/roc](https://go.dev/cl/25058) 运行时：用 ROC 编写屏障代码
  + [cl/generational-gc](https://go.dev/cl/137482) 运行时：触发器生成GC
- [doc/ismm-gc](https://go.dev/blog/ismmkeynote) Rick Hudson，Go 垃圾收集器之旅。
- [discuss/ismm-gc](https://groups.google.com/forum/#!topic/golang-dev/UuDv7W1Hsns) 垃圾回收 Slides 和 Transcritp 已可用。
- [design/simplify-mark-termination](https://go.dev/design/26903-simplify-mark-termination) Austin Clements，提案：简略标记终止和消除标记2。2018年8月9日。
  + [issue/26903](https://go.dev/issue/26903) 运行时：简略标记终止和消除标记2
- [design/gcscan](https://docs.google.com/document/d/1un-Jn47yByHL7I0aVIP_uVCMxjdM5mpelJhiKlIqxkE/edit#) 提案：堆栈的GC扫描
  + [issue/22350](https://go.dev/issue/22350) cmd/compile: 编译器莫名其妙地保留内存。
- [issue/27993](https://go.dev/issue/27993) 运行时：错误消息：在标记终止时 P 会缓存 GC 内容。
- [issue/37116](https://go.dev/issue/37116) 运行时：在 Go1.14rc1 中 GC 会延迟 10ms-26ms，可能因为 GC 空闲。
- [issue/42430](https://go.dev/issue/42430) 运行时：GC 里 pacer 问题讨论
  + [issue/39983](https://go.dev/issue/39983) 运行时：空闲的GC妨碍自动缩放
  + [issue/17969](https://go.dev/issue/17969) 运行时：侵略型的GC实现会干扰共同租户。
  + [issue/14812](https://go.dev/issue/14812) 运行时：GC 导致延迟峰值。
  + [issue/40460](https://go.dev/issue/40460) 运行时：goroutine 可能分配超出硬堆目标。
  + [issue/29696](https://go.dev/issue/29696) 提案：运行时：为应用增加回应GC反压力的方式。
  + [issue/23044](https://go.dev/issue/23044) 提案：运行时：添加一种机制来指定最小目标堆大小
- [issue/42642](https://go.dev/issue/42642) 运行时：多毫秒扫描终止暂停（第二版）
- [issue/44163](https://go.dev/issue/44163) 运行时：删除空闲的GC工作者。
- [issue/44167](https://go.dev/issue/44167) 运行时：重新设计 GC Pacer
  + [design/gc-pacer-redesign](https://go.dev/design/44167-gc-pacer-redesign) 重新设计 GC Pacer
- [issue/44309](https://go.dev/issue/44309) 提案：runtime/debug: 用户可配置目标内存
- [issue/48409](https://go.dev/issue/48409) 提案：runtime/debug: 软内存限制
  + [design/user-configurable-memory-target](https://go.dev/design/44309-user-configurable-memory-target) 用户可配置目标内存
  + [design/soft-memory-limit](https://go.dev/design/48409-soft-memory-limit) 软内存限制
- [issue/45894](https://go.dev/issue/45894) 运行时：标记终止重启突变太慢。
- [issue/45315](https://go.dev/issue/45315) 运行时：runtime.GC 无需完成扫描就能返回。

[Back To Top](#top)

### 统计

- [issue/16843](https://go.dev/issue/16843) 运行时：用于监控堆大小的机制
  + [cl/setmaxheap](https://go-review.googlesource.com/c/go/+/46751/) Austin Clements，runtime/debug：添加 SetMaxHeap 应用接口。2017年6月26日。
- [design/go116runtime-metric](https://github.com/golang/proposal/blob/44d4d942c03cd8642cef3eb2f6c153f2e9883a77/design/37112-unstable-runtime-metrics.md) Michael Knyszek，提案：用于不稳定运行时的指标应用接口。2020年3月18日。
- [issue/19812](https://go.dev/issue/19812) 运行时：在GC期间无法 ReadMemStats。
- [issue/38712](https://go.dev/issue/38712) 运行时：TestMemStats 很奇怪
- [issue/40459](https://go.dev/issue/40459) 运行时：在循环中调用 ReadMemStats 可能阻止GC

[Back To Top](#top)

### 内存模型

Go 内存模型包含以下方面：

- 关于原子操作的内存顺序
- 关于 sync 包应用接口的内存顺序
- 关于运行时机制的内存顺序（即对象终结器）
- [doc/refmem](https://go.dev/ref/mem) Rob Pike 和 Russ Cox。Go 内存模型。2009年2月21日。
- [issue/4947](https://go.dev/issue/4947) cmd/cc: 原子的实质
- [issue/5045](https://go.dev/issue/5045) 文档：定义 sync/atomic 和内存模型怎样交互
- [issue/7948](https://go.dev/issue/7948) 文档：定义 sync 和内存模型怎样交互
- [issue/9442](https://go.dev/issue/9442) 文档：定义 finalizers 和内存模型怎样交互
- [issue/33815](https://go.dev/issue/33815) doc/go_mem: "hello, world" 并不总是打印两次
- [cl/75130045](https://codereview.appspot.com/75130045) 文档：允许缓冲通道在未初始化时作为信号量
- [doc/gomem](http://nil.csail.mit.edu/6.824/2016/notes/gomem.pdf) Russ Cox。Go 内存模型。2016年2月25日。
- [doc/go2017russ](https://research.swtch.com/go2017#memory) Russ Cox，我的Go决议2017：内存模型。2017年1月18日。
- [doc/atomic-bug](https://go.dev/pkg/sync/atomic/#pkg-note-BUG) atomic 包
- [discuss/atomic-mem-order](https://groups.google.com/d/msg/golang-dev/vVkH_9fl1D8/azJa10lkAwAJ) 通过 atomic 的 Load/Store 来提供内存顺序保证。
- [issue/37355](https://go.dev/issue/37355) runtime/race: 使用 -race 运行但没有 race（与内存模型不匹配）
  + [cl/220419](https://go.dev/cl/220419) 运行时：交换 raceacquire() 和 racerelease 的顺序
  + [issue/42598](https://go.dev/issue/42598) 运行时：在 CL 220419 后缓冲通道的明显错误的竞争报告。
  + [cl/271987](https://go.dev/cl/271987) 运行时：在调用竞争检测器前检查通道的 elemsize
  + [paper/fava2020fix] Fava, Daniel Schnetzer，“查找并修复Go内存模型和数据竞争检测器间的不匹配。”软件工程和格式化方法的国际化会议。2020年 Springer, Cham。
- [doc/mm](https://research.swtch.com/mm) Russ Cox，内存模型，2021年6月
  + [doc/hwmm](https://research.swtch.com/hwmm) Russ Cox，硬件内存模型。2021年6月29日。
  + [doc/plmm](https://research.swtch.com/plmm) Russ Cox，编程语言内存模型。2021年7月6日。
  + [doc/gomm](https://research.swtch.com/gomm) Russ Cox，更新Go内存模型。2021年7月12日。
  + [discuss/47141](https://github.com/golang/go/discussions/47141) 更新Go内存模型。

[Back To Top](#top)

### ABI

- [design/cgo-pointers](https://go.dev/design/12416-cgo-pointers) Ian Lance Taylor，提案：在Go和C之间传递指针的规则。2015年10月。
  + [issue/12416](https://go.dev/issue/12416) cmd/cgo: 指定Go和C之间传递指针的规则。
- [design/internal-abi](https://go.dev/design/27539-internal-abi) Austin Clements. 创建未定义的内部调用规定。2019年1月14日。
  + [issue/27539](https://go.dev/issue/27539) 提案：运行时：使 ABI 未定义，作为更改的步骤。
  + [issue/31193](https://go.dev/issue/31193) cmd/compile，运行时：减少函数开头的开销。
- [design/register-call](https://go.dev/design/40724-register-calling) Austin Clements, 另有 Cherry Zhang, Michael Knyszek, Martin Möhrmann, Michael Pratt, David Chase, Keith Randall, Dan Scales, and Ian Lance Taylor 提供建议。提案：基于注册的Go调用协议。2020年8月10日。
- [issue/18597](https://go.dev/issue/18597) 提案: cmd/compile: 定义基于注册的调用协议。
- [issue/40724](https://go.dev/issue/40724) 提案：Go 函数切换到基于注册的调用协议。
  + [cl/266638](https://go.dev/cl/266638) 反射、运行时：为 ASM 例程使用内部 ABI，第二次尝试。
  + [cl/259445](https://go.dev/cl/259445) cmd/compile,cmd/link: 为ABI包装器的初始支持
- [design/internal-abi-spec](https://github.com/golang/go/blob/master/src/cmd/compile/abi-internal.md) Go 内部ABI规范。

[Back To Top](#top)

### Misc

- [issue/20135](https://go.dev/issue/20135) 运行时：删除元素时map收缩。

[Back To Top](#top)

## 标准库

### syscall

- [design/go14syscall](https://go.dev/s/go1.4-syscall) syscal 包。

[Back To Top](#top)

### os, io, io/fs, embed

Go 1.16 中，对新的 os/fs 包进行了大量返工和改进。
[design/draft-iofs](https://go.dev/design/draft-iofs) Russ Cox, Rob Pike，Go 文件系统接口——设计草案。2020年7月。

  + [issue/13473](https://go.dev/issue/13473) 提案：os: Stdin, Stdout 和 Stderr 应该是接口
  + [issue/14106](https://go.dev/issue/14106) 提案：os：File 应该是接口
  + [issue/19660](https://go.dev/issue/19660) 提案: 将 io/ioutil 重命名为 io/fileio 或类似名字
  + [issue/40025](https://go.dev/issue/40025) 提案: io/ioutil: 移动 Discard, NopCloser, ReadAll 到 io
  + [issue/42027](https://go.dev/issue/40027) 提案: path/filepath: 添加 WalkDir (使用 DirEntry 浏览)
  + [issue/41190](https://go.dev/issue/41190) io/fs: 添加文件系统接口
  + [issue/41467](https://go.dev/issue/41467) os: 为轻量级目录查询添加 ReadDir 方法。
  + [issue/41974](https://go.dev/issue/41974) 提案: io/fs, filepath: 添加高效的浏览替代方案。
  + [issue/42026](https://go.dev/issue/42026) 提案: os: 添加 ReadDir, ReadFile, WriteFile, CreateTemp, MkdirTemp，以及反对 io/ioutil
  + [issue/43223](https://go.dev/issue/43223) 提案: io/fs, net/http: 定义自动 ETag 服务的接口
- [design/go116embed](https://go.dev/s/draft-embed-design) Russ 和 Braid，嵌入文件。
  + [issue/41191](https://go.dev/issue/41191) embed, cmd/go: 添加嵌入文件的支持
  + [issue/42321](https://go.dev/issue/42321) embed: 在 embed.FS 文档中应该加入警告，说明包含点文件
  + [issue/42328](https://go.dev/issue/42328) 提案: cmd/go: 在使用 `//go:embed`时避免包含隐藏文件
  + [issue/43216](https://go.dev/issue/43216) 提案: embed: 删除在本地变量上对嵌入指令的支持
  + [issue/43217](https://go.dev/issue/43217) 提案: embed: 定义 String 和 Bytes 类型别名时必须使用 `//go:embed`
  + [issue/43218](https://go.dev/issue/43218) embed: 对 string, []byte 讨论的决定
  + [issue/44166](https://go.dev/issue/44166) io/fs,os: 使用 os.DirFS 的 fs.ReadDir 会造成错误的路径
  + [issue/42322](https://go.dev/issue/42322) io/fs: 添加函数 `Sub(fsys FS, dir string) FS`

[Back To Top](#top)

### go/*

- [doc/gotypes](https://go.dev/s/types-tutorial) Alan Donovan. go/types: Go 类型检查器
- [talk/gotypes](https://docs.google.com/presentation/d/13OvHYozAUBeISPRoLgG7kMBuja1NsU1D_mMlmbaYojk/view) Alan Donovan. 使用 go/types 作为代码理解和重构工具。2015年12月2日。
- [design/modular-interface](https://docs.google.com/document/d/1-azPLXaLgTCKeKDNg0HVMq2ovMlD-e7n1ZHzZVzOlJk/edit) Alan Donovan. 提案：用于Go模块化静态分析的通用接口。2018年9月9日。
  + [cl/134935](https://go.dev/cl/134935) go/analysis: 分析工具的新的应用接口

[Back To Top](#top)

### sync

- [design/percpu-sharded](https://go.dev/design/18802-percpu-sharded) Sanjay Menakuru. 提案：percpu.Sharded，一个用来减少缓存竞争的应用接口。2018年6月12日。
  + [issue/18802](https://go.dev/issue/18802) 提案：sync: 支持分片值
- [issue/37142](https://go.dev/issue/37142) sync: sync 包里的收缩类型

[Back To Top](#top)

#### Map

- [issue/21031](https://go.dev/issue/21031) sync: 减少 map 里的指针开销
- [issue/21032](https://go.dev/issue/21032) sync: 用存储新键值来减少 (*map).Load 的损失
- [issue/21035](https://go.dev/issue/21035) sync: 通过新的不相交的键来减少Map操作间的竞争
- [issue/37033](https://go.dev/issue/37033) 运行时：提供集中的工具来管理 go/cgo 的指针句柄

[Back To Top](#top)

#### Pool

- [discuss/add-pool](https://groups.google.com/d/msg/golang-dev/kJ_R6vYVYHU/LjoGriFTYxMJ) gc-aware 池耗尽策略
- [issue/4720](https://go.dev/issue/4720) sync：添加池类型，2013年1月28日。
- [cl/46010043](https://github.com/golang/go/commit/f8e0057bb71cded5bb2d0b09c6292b13c59b5748#diff-2e9fc106a7387ca4c32ecf856a91f82a) sync: 缩放池，2014年1月24日。
- [cl/86020043](https://github.com/golang/go/commit/8fc6ed4c8901d13fe1a5aa176b0ba808e2855af5#diff-2e9fc106a7387ca4c32ecf856a91f82a) sync: 池里减少激进的本地缓存，2014年4月14日。
- [cl/162980043](https://github.com/golang/go/commit/af3868f1879c7f8bef1a4ac43cfe1ab1304ad6a4#diff-491b0013c82345bf6cfa937bd78b690d) sync: 在第二次和之后的GC期间释放池内存，2014年10月22日。
- [issue/8979](https://go.dev/issue/8979) sync: 在GC期间池没有释放内存。
- [issue/22331](https://go.dev/issue/22331) 运行时：池清理导致 STW1 时间过长。
- [issue/22950](https://go.dev/issue/22950) sync: 避免每次GC都清理全部池。
  + [cl/166960](https://github.com/golang/go/commit/d5fd2dd6a17a816b7dfd99d4df70a85f1bf0de31) sync: 使用无锁结构进行池窃取。
  + [cl/166961](https://github.com/golang/go/commit/2dcbf8b3691e72d1b04e9376488cef3b6f93b286) sync: 使用受害者缓存在GC上进行平缓的池操作。
- [issue/24479](https://go.dev/issue/24479) sync: 在池操作里去除全部 Mutex。

[Back To Top](#top)

#### Mutex, RWMutex

- [cl/4631059](https://go.dev/cl/4631059) 运行时：替换 Semacquire/Semrelease 实现。
- [issue/9201](https://go.dev/issue/9201) 提案：同步：禁止解锁不同 goroutine 的 mutex。
- [issue/13086](https://go.dev/issue/13086) 运行时：在重复睡眠获取失败后回退到公平锁。
  + [cl/34310](https://go.dev/cl/34310) sync: 让 Mutex 更公平。
- [issue/17973](https://go.dev/issue/17973) sync: RWMutex 无法随 CPU 数量扩展。
  + [cl/215361](https://go.dev/cl/215361) sync: 实现能够避免缓存竞争的 RWMutex 版本。


[Back To Top](#top)

#### Groups

- [cl/134395](https://go.dev/cl/134395) errgroup: 重新考虑并发模式。
  + [cl/131815](https://go.dev/cl/131815) errgroup: 句柄运行时。从子 goroutine 进行 Goexit。
  + [issue/15758](https://go.dev/issue/15758) testing: 同时使用 T.FatalX 和 T.SkipX 时应该提示错误。
  + [issue/25448](https://go.dev/issue/25448) 提案：将`panic(nil)`改为非空的panic值。

[Back To Top](#top)

#### atomic

- [issue/8739](https://go.dev/issue/8739) runtime,sync/atomic: 统一 runtime/internal/atomic 和 sync/atomic 的应用接口。
- [issue/20164](https://go.dev/issue/20164) 提案: atomic: 添加 `(*Value).Swap`
- [discuss/atomic-value](https://groups.google.com/g/golang-dev/c/SBmIen68ys0/m/WGfYQQSO4nAJ)
- [issue/36606](https://go.dev/issue/36606) 提案: cmd/compile: 让64位字段在32位系统上对齐为64位，在结构上添加 `//go:packed`指令
- [issue/37262](https://go.dev/issue/37262) 运行时：在32位架构上不能原子性地访问 tiny-allocated 结构的第一个字。

[Back To Top](#top)

### time

- [design/monotonic-time](https://go.dev/design/12914-monotonic) Russ Cox，提案：Go 中单调经过的时间跨度。2017年1月26日。
  + [issue/12914](https://go.dev/issue/12914) time: 使用单调时钟测量经过的时间
- 可扩展的计时器
  + [cl/34784](https://go.dev/cl/34784) 运行时：在多 CPU 系统上的计时器可扩展性。
  + [issue/6239](https://go.dev/issue/6239) 运行时：让计时器更快。
  + [issue/15133](https://go.dev/issue/15133) 运行时：计时器无法在有大量计时器的多CPU系统上扩展。
  + [issue/27707](https://go.dev/issue/27707) time: 	当使用 Ticker 和 Sleep 时CPU使用率过高。
- 后续的延迟讨论
  + [issue/18023](https://go.dev/issue/18023) 运行时：使用 runtime.LockOSThread 意外会大幅减慢。
  + [issue/25471](https://go.dev/issue/25471) time: 需要大约7次 syscall 才会睡眠。
  + [issue/38070](https://go.dev/issue/38070) 运行时：因为抢占点导致计时器自己死锁。
  + [issue/36298](https://go.dev/issue/36298) net: mac 上的 1.14 版本性能减弱。
  + [issue/38860](https://go.dev/issue/38860) 运行时：CPU 限制 goroutine 导致不必要的计时器延迟。
     + [cl/216198](https://go.dev/cl/216198) 运行时：将 poller 返回的 goroutine 添加进本地运行队列。
     + [cl/232199](https://go.dev/cl/232199) 运行时：从运行中的 P's 中窃取计时器。
     + [cl/232298](https://go.dev/cl/232298) 运行时：减少计时器延迟。
  + [issue/44343](https://go.dev/issue/44343) 运行时：time.Sleep 比预计时间更长
  + [issue/44868](https://go.dev/issue/44868) time, runtime: 零间隔的计时器需要2分钟才能启动。

[Back To Top](#top)

### context

- [issue/8082](https://go.dev/issue/8082) 提案：规范：通过接口的定义而不是包和名字来表示接口。
- [issue/14660](https://go.dev/issue/14660) 提案：context: 标准库的新包。
- [issue/16209](https://go.dev/issue/16209) 提案：放宽名称不同但实际相同的接口的分配规则。
- [issue/20280](https://go.dev/issue/20280) 提案: io: 向 Reader 等添加 Context 参数。
- [issue/21355](https://go.dev/issue/21355) 提案：让 Context 使用本地 goroutine 存储
- [issue/24050](https://go.dev/issue/24050) testing: 在1.10上使用子进程测试有时会挂住。
- [issue/27982](https://go.dev/issue/27982) 提案: Go 2: 加入协作式 goroutine 取消机制
- [issue/28342](https://go.dev/issue/28342) 提案: Go 2: 更新 context 包
- [issue/29011](https://go.dev/issue/29011) 提案: Go 2: 使用结构化的并发
- [doc/context-go-away](https://faiface.github.io/post/context-should-go-away-go2/) Michal Štrba，Go 2 应该取消 Context，2017年8月6日。
- [doc/context](https://go.dev/blog/context) Go 并发模式: Context。
- [doc/context-isnt-for-cancellation](https://dave.cheney.net/2017/08/20/context-isnt-for-cancellation) Dave Cheney，Context 不适用取消。
- [issue/42564](https://go.dev/issue/42564) context: cancelCtx 独占锁导致极端的竞争。

[Back To Top](#top)

### encoding

- [design/go12encoding](https://go.dev/s/go12encoding) Russ Cox，Go 1.2里的 encoding，TextMarshaler 和 TextUnmarshaler，2013年7月。
- [design/go12xml](https://docs.google.com/document/d/1G-AMeUPoyTnbZDkuCJA89DjJwTjdWFctIZ_N9NgA9RM/pub) Russ Cox，Go 1.2 里的 xml.Marshaler 和 Unmarshaler，2013年7月。
- [design/natural-xml](https://go.dev/design/13504-natural-xml) Sam Whited，提案: 原生 XML. 2016年9月27日。
  + [issue/13504](https://go.dev/issue/13504) encoding/xml: 添加 XML 数据的通用表现形式。
- [design/zip](https://go.dev/design/14386-zip-package-archives) Russ Cox，提案：基于 Zip 的 Go 包存档，2016年2月。
  + [issue/14386](https://go.dev/issue/14386) 提案：在 .a 和 .o 文件中使用 zip 格式。
- [design/xmlstream](https://go.dev/design/19480-xml-stream) Sam Whited，建议：XML 流。2017年3月9日。
  + [issue/19480](https://go.dev/issue/19480) encoding/xml: 从 TokenReader 添加解码，启用流转换器。
- [design/raw-xml](https://go.dev/design/26756-rawxml-token) Sam Whited，提案：原始 XML 令牌，2018年9月1日。
  + [issue/26756](https://go.dev/issue/26756) 提案: encoding/xml: 添加 RawXML 令牌。

[Back To Top](#top)

### image, x/image

以下的讨论关于颜色管理和图片标准库。现在，Go图片库不会在编码和解码期间读取或写入元信息。因此，在处理图片时（例如在非线性 sRGB 空间中缩放），颜色可能出错。通用解决方案是设计图片元数据API，来识别编码图片文件中的颜色配置文件。

- [issue/11420](https://go.dev/issue/11420) x/image/draw: 颜色空间校正插值
  + [issue/20613](https://go.dev/issue/20613) image/png: 不要忽略 PNG gAMA块
  + [issue/27830](https://go.dev/issue/27830) 提案: image: 解码选项
  + [cl/253497](https://go.dev/cl/253497) x/image/draw: 伽玛校正非线性插值
  + [issue/37188](https://go.dev/issue/37188) image/color: 文档没有包含指向颜色理论资源的链接
- [issue/33457](https://go.dev/issue/33457) 提案: image: 添加对 jpeg、gif、png 的通用元数据支持
  + [discuss/image-metadata](https://groups.google.com/g/golang-dev/c/aRvnYIcaIaA/m/9GVKL7mIAgAJ) image.Metadata 接口类型
  + [issue/18365](https://go.dev/issue/18365) image/png: 不支持设计和检索 PPI/DPI
  + [cl/208559](https://go.dev/cl/208559) image: 新的元数据感知读写API
  + [cl/216799](https://go.dev/cl/216799) image: 元数据API草图
- [issue/44808](https://go.dev/issue/44808) image, image/draw: 添加直接使用 RGBA64 的接口
- [issue/46395](https://go.dev/issue/46395) image/draw: 如果掩码是 *image.Alpha，通过使用特殊情况来提升性能。


<!--
TODO: read all of these!
These issues are discussion the current performance issue that exist in the current implementation.

- [issue/8055](https://go.dev/issue/8055) image: decode / resize into an existing buffer
- [issue/11793](https://go.dev/issue/11793) image/color: NRGBA(64).RGBA() optimization
- [issue/15759](https://go.dev/issue/15759) image: optimize Image.At().RGBA()
- [issue/20851](https://go.dev/issue/20851) image: Decode drops interfaces
- [issue/24499](https://go.dev/issue/24499) image/jpeg: Decode is slow


- [issue/22535](https://go.dev/issue/22535) image: support LJPEG
- [issue/18098](https://go.dev/issue/18098) proposal: add Validate functions to image/jpeg, image/png etc.
- [issue/2362](https://go.dev/issue/2362) image/jpeg: chroma downsampling ratios are restricted
- [issue/4341](https://go.dev/issue/4341) image/jpeg: correct for EXIF orientation?
- [issue/10447](https://go.dev/issue/10447) image/jpeg: add options to partially decode or tolerantly decode invalid images?
- [issue/12202](https://go.dev/issue/12202) image/jpeg: specify APP1 segment for outputting EXIF data in jpeg.Encode()?
- [issue/13614](https://go.dev/issue/13614) image/jpeg: add a jpeg option to disable chroma subsampling
- [issue/22170](https://go.dev/issue/22170) image/jpeg: Unable to decode concatenated JPEGs (MIME-less "MJPEG")
- [issue/23936](https://go.dev/issue/23936) image/jpeg: encoding with RGB profile causing loss of image saturation
- [issue/29512](https://go.dev/issue/29512) image/jpeg: support for yuvj444p jpeg images
- [issue/40130](https://go.dev/issue/40130) image/jpeg: "bad RST marker" error when decoding
- [issue/6635](https://go.dev/issue/6635) image/gif: encoder does not honor image bounds.
- [issue/5050](https://go.dev/issue/5050) image/gif: decoding untrusted (very large) images can cause huge memory allocations
- [issue/26108](https://go.dev/issue/26108) image/gif: encoded images incompatible with some viewers
- [issue/20694](https://go.dev/issue/20694) image/gif: Mention the uselessness of BackgroundIndex in the docs Documentation
- [issue/20804](https://go.dev/issue/20804) image/gif: decoding gif returns `unknown block type: 0x01` error
- [issue/20856](https://go.dev/issue/20856) image/gif: decoding gif returns `frame bounds larger than image bounds` error
- [issue/33748](https://go.dev/issue/33748) image/gif: generated image cannot be opened in xv and crashes OmniWeb 3.x web browser
- [issue/35166](https://go.dev/issue/35166) image/gif: TestDecodeMemoryConsumption flake on dragonfly-amd64
- [issue/35503](https://go.dev/issue/35503) image/gif: decode fails with "gif: too much image data"
- [issue/38958](https://go.dev/issue/38958) image/gif: "not enough image data" on gif that works in browser
- [issue/38853](https://go.dev/issue/38853) image/gif: GIF files with extraneous 0x00 bytes cause "gif: unknown block type: 0x00"
- [issue/41142](https://go.dev/issue/41142) image/gif: Decode reads the entire animated gif image, even though it returns only the first frame (while DecodeAll exists to read and return all frames)

x/image:

- [issue/40173](https://go.dev/issue/40173) x/image: WebP decode contrast issue
- [issue/39705](https://go.dev/issue/39705) x/image: CCITT reader EOF error for tiff image
- [issue/25657](https://go.dev/issue/25657) x/image: vector.go rasterizer shifts alpha mask and is slow when target is offset and small relative image size
- [issue/39900](https://go.dev/issue/39900) x/image/tiff: Missing raw stream read/write
- [issue/38252](https://go.dev/issue/38252) x/image/tiff: add 32bit float grayscale support
- [issue/36121](https://go.dev/issue/36121) x/image/tiff: grayscale tiled images are not decoded correctly
- [issue/33708](https://go.dev/issue/33708) x/image/tiff: sony .arw files decode as a 0x0 image.Gray
- [issue/30827](https://go.dev/issue/30827) x/image/tiff: unexpected EOF
- [issue/26450](https://go.dev/issue/26450) x/image/tiff: implement a generic tiff parser
- [issue/26360](https://go.dev/issue/26360) x/image/tiff: compressed tiffs are invalid (at least on Mac OS X)
- [issue/23115](https://go.dev/issue/23115) x/image/tiff: no support for cJPEG or cJPEGOld
- [issue/20742](https://go.dev/issue/20742) x/image/tiff: package does not support image resolution
- [issue/11413](https://go.dev/issue/11413) x/image/tiff: invalid format: wrong number of samples for RGB
- [issue/11389](https://go.dev/issue/11389) x/image/tiff: excessive memory consumption
- [issue/11386](https://go.dev/issue/11386) x/image/tiff: index out of range
- [issue/19672](https://go.dev/issue/19672) x/image/webp: issue with colors contrast when converting to jpeg/png
- [issue/30902](https://go.dev/issue/30902) x/image/riff: Implement write functionality
- [issue/29711](https://go.dev/issue/29711) x/image/bmp: support 1-bit format
- [issue/37532](https://go.dev/issue/37532) x/image/font/gofont: Go Mono font readability for users
- [issue/37441](https://go.dev/issue/37441) x/image/font/gofont: Go fonts not representative of OpenType state of the art
- [issue/30699](https://go.dev/issue/30699) x/image/font/sfnt: read more glyph metrics
- [issue/28932](https://go.dev/issue/28932) x/image/font: wrong rendering of intersecting paths
- [issue/28380](https://go.dev/issue/28380) x/image/font/sfnt: support trimmed table mapping cmap format
- [issue/27281](https://go.dev/issue/27281) x/image/font: rendering texts in Arabic
- [issue/23497](https://go.dev/issue/23497) x/image/font/gofont/gomedium: wrong shape for "l" letter
- [issue/22451](https://go.dev/issue/22451) x/image/font/sfnt: implement font.Face
- [issue/20208](https://go.dev/issue/20208) x/image/font: Tool for running Unicode’s text rendering tests
- [issue/14436](https://go.dev/issue/14436) x/image/font: make it easier to measure a string's bounds and draw it in a bounding box
- [issue/33990](https://go.dev/issue/33990) x/image/font/sfnt: GlyphName returns empty string on OpenType font
- [issue/16904](https://go.dev/issue/16904) proposal: x/image packages to render TrueType fonts -->

[Back To Top](#top)

### Mobile

- [design/go14android](https://go.dev/s/go14android) David Crawshaw，Go 支持安卓，2014年6月。
- [design/gobind](https://go.dev/s/gobind) David Crawshaw，绑定Go和Java，2014年7月。

[Back To Top](#top)

### misc

- [design/mobile-audio](https://go.dev/design/13432-mobile-audio) Jaana Burcu Dogan，提案：手机音频。2015年11月30日。
  + [issue/13432](https://go.dev/issue/13432) 提案: x/mobile 音频
- [design/localization](https://go.dev/design/12750-localization) Marcel van Lohuizen，提案：Go 本地化支持。2016年1月28日。
  + [issue/12750](https://go.dev/issue/12750) x/text: 本地化支持
- [design/unbounded-queue](https://go.dev/design/27935-unbounded-queue-package) Christian Petrin，提案：内置高性能无界队列。2018年10月2日。
  + [issue/27935](https://go.dev/issue/27935) 提案: 添加 container/queue
- [design/lockfile](https://go.dev/design/33974-add-public-lockedfile-pkg) Adrien Delorme，公开内部的锁定文件包
  + [issue/33974](https://go.dev/issue/33974)
- [design/cidr](https://go.dev/design/16704-cidr-notation-no-proxy) Rudi Kramer, James Forrest，在 no_proxy 变量中添加对CIDR表示法的支持。2017年7月10日。
  + [issue/16704](https://go.dev/issue/16704) net/http: 考虑在 no_proxy 环境变量添加 CIDR 表示法
- [design/dns](https://go.dev/design/26160-dns-based-vanity-imports) Sam Whited，提案：基于DNS的虚导入。2018年6月30日。
  + [issue/26160](https://go.dev/issue/26160) 提案：将 DNS 文本记录用于虚导入路径

[Back To Top](#top)

## 未分类但相关的链接

- [使用Go Guru：用于导航Go代码的集成编辑器工具，Alan Donovan。](https://go.dev/s/using-guru)
- [Go Guru 计划 (née Oracle) ，Alan Donovan。](https://docs.google.com/document/d/1UErU12vR7jTedYvKHVNRzGPmXqdMASZ6PfE7B-p6sIg/edit)
- [为什么 X 在标准库中？（已放弃、未完成）](https://go.dev/s/stdwhy)
- [go oracle: 设计，Alan Donovan。](https://go.dev/s/oracle-design)
- [go oracle: 用户手册，Alan Donovan。](https://go.dev/s/oracle-user-manual)
- [cgihttpproxy](https://go.dev/s/cgihttpproxy)
- [sqldrivers](https://go.dev/s/sqldrivers)
- [Go 2 设计](https://go.dev/s/go2designs)
- [C编程语言笔记，Rob Pike。](http://doc.cat-v.org/bell_labs/pikestyle)
- [”我得到的最好的编程建议“，Rob Pike。](https://www.informit.com/articles/article.aspx?p=1941206)
- [Mihai Budiu 对 Brian Kernighan 的采访](http://www.cs.cmu.edu/~mihaib/kernighan-interview/index.html)
- [语言设计，Brian Kernighan Holiday Repeat By SE Daily](https://softwareengineeringdaily.com/2017/12/28/language-design-with-brian-kernighan-holiday-repeat/)
- [C 编程语言: Brian Kernighan - Computerphile](https://youtu.be/de2Hsvxaf8M)
- [调试Go程序中的性能问题，Dmitriy Vyukov。](https://software.intel.com/content/www/us/en/develop/blogs/debugging-performance-issues-in-go-programs.html)
- [我想实现的有趣的论文（或者有部分实现）](https://github.com/dgryski/interesting-papers)
- [golang/wiki/ResearchPapers](https://github.com/golang/go/wiki/ResearchPapers)

[Back To Top](#top)

## 有趣的事实

- [cl/1](https://github.com/golang/go/commit/7d7c6a97f815e9279d08cfaea7d5efb5e90695a8) Brian Kernighan，Go的首次提交。1972年7月19日。
- [issue/9](https://go.dev/issue/9) 我使用了 MY 作为编程语言的名字，2009年11月11日。
- [issue/2870](https://go.dev/issue/2870) 9 不是素数，2012年2月3日。
- [doc/gophercount](https://research.swtch.com/gophercount) 有多少 Go 开发者？2019年11月1日。
- [discuss/google-owns-go](https://groups.google.com/forum/#!msg/golang-nuts/6dKNSN0M_kg/Y1yDJRwQBgAJ) Russ Cox 关于“Go是谷歌的语言，不是我们的语言”的回应。

[Back To Top](#top)

## 鸣谢

首先感谢 [TalkGo](https://github.com/talkgo) 社区创建者 [Mai Yang](https://github.com/yangwenmai) 对 [golang.design](https://golang.design/) 倡议的大力推动。他创建的 TalkGo 极大地改变了中国的 Go 社区。他也是一个伟大的人，积极为各种与 Go 相关的项目作贡献。

同样重要的是感谢 TalkGo 社区核心成员 [qcrao](https://github.com/qcrao) 和 [eddycjy](https://github.com/eddycjy) 的持续而鼓舞人心的讨论和分享。

如果没有他们的支持，此文档无法完成。

[Back To Top](#top)

## 许可

[golang.design/history](https://github.com/golang-design/history) | CC-BY-NC-ND 4.0 © [changkun](https://changkun.de/)
